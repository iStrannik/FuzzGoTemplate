<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SCov &gt; funcs.go</title>
<meta name="description" content="Code coverage report">
<meta name="generator" content="https://gitlab.com/stone.code/scov">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
<!--[if lte IE 8]>
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-old-ie-min.css">
<![endif]-->
<!--[if gt IE 8]><!-->
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css">
<!--<![endif]-->
<style>
html { padding:1em; }
body { max-width:70em; margin:auto; }
table { margin-bottom: 1em; }
.coverage { min-width:100%; }
.coverage td:nth-child(2), .coverage th:nth-child(2) { text-align:center; }
.coverage td:nth-child(3), .coverage th:nth-child(3) { text-align:center; }
.coverage td:nth-child(4), .coverage th:nth-child(4) { text-align:center; }
.sparkbar { border: 1px solid black; border-radius:1px; min-width:50px; height:1em; }
.sparkbar .fill { display: inline-block; height: 100%; }
.sparkbar .high { background-color:lightgreen; }
.sparkbar .medium { background-color:yellow; }
.sparkbar .low { background-color:red; }
.sparkbar .empty { display: inline-block; height: 1em; background-color: white; }
.source { font-family: monospace; width:100%; margin:0; }
.source th { padding: .1em .5em; text-align:left; border-bottom: 1px solid black; }
.source td { padding: .1em .5em; white-space: pre; }
.source .hit { background:lightblue; }
.source .miss { background:LightCoral; }
.source td:nth-child(1), .source th:nth-child(1) { background:PaleGoldenrod; text-align:right; }
.source td:nth-child(2), .source th:nth-child(2) { background:#f6f3d4; text-align:right; }
footer { border-top: 1px solid rgb(203, 203, 203); margin-top: 1em; background: #e0e0e0; padding: .5em 1em; }
@media screen and (min-width: 48em) {
	.pure-gutter-md > div { box-sizing: border-box; padding: 0 0.5em; }
	.pure-gutter-md > div:first-child { padding-left: 0; }
	.pure-gutter-md > div:last-child { padding-right: 0; }
}
@media screen and (max-width: 48em) {
	.table-md td, .table-md th { padding: 0.5em; }
}
</style>
</head>
<body>
<div class="pure-g"><h1 class="pure-u">SCov &gt; funcs.go</h1></div>
<div class="pure-g pure-gutter-md"><div class="pure-u-1 pure-u-md-1-2">
<h2>Metadata</h2>
<table class="pure-table pure-table-horizontal">
<tr><td>Date:</td><td>Sun Apr  2 22:02:43 UTC 2023</td></tr>
<tr><td>Filename:</td><td>text/template/funcs.go</td></tr>
</table>
</div><div class="pure-u-1 pure-u-md-1-2">
<h2>Coverage</h2>
<table class="pure-table pure-table-horizontal coverage">
<thead><tr><th></th><th>Hits</th><th>Total</th><th>Coverage</th></tr></thead>
<tbody>
<tr><td>Lines:</td><td>60</td><td>509</td><td>11.8%</td></tr>
<tr><td>Regions:</td><td>22</td><td>246</td><td>8.9%</td></tr>
</tbody>
</table>
</div></div>
<div class="pure-g"><div class="pure-u">
<h2>File Listing</h2>
<table class="source"><thead>
<tr><th>Line #</th><th>Hit count</th><th>Source code</th></tr>
</thead><tbody>
<tr id="L1"><td>1</td><td></td><td>// Copyright 2011 The Go Authors. All rights reserved.</td></tr>
<tr id="L2"><td>2</td><td></td><td>// Use of this source code is governed by a BSD-style</td></tr>
<tr id="L3"><td>3</td><td></td><td>// license that can be found in the LICENSE file.</td></tr>
<tr id="L4"><td>4</td><td></td><td></td></tr>
<tr id="L5"><td>5</td><td></td><td>package template</td></tr>
<tr id="L6"><td>6</td><td></td><td></td></tr>
<tr id="L7"><td>7</td><td></td><td>import (</td></tr>
<tr id="L8"><td>8</td><td></td><td>	&#34;errors&#34;</td></tr>
<tr id="L9"><td>9</td><td></td><td>	&#34;fmt&#34;</td></tr>
<tr id="L10"><td>10</td><td></td><td>	&#34;io&#34;</td></tr>
<tr id="L11"><td>11</td><td></td><td>	&#34;net/url&#34;</td></tr>
<tr id="L12"><td>12</td><td></td><td>	&#34;reflect&#34;</td></tr>
<tr id="L13"><td>13</td><td></td><td>	&#34;strings&#34;</td></tr>
<tr id="L14"><td>14</td><td></td><td>	&#34;sync&#34;</td></tr>
<tr id="L15"><td>15</td><td></td><td>	&#34;unicode&#34;</td></tr>
<tr id="L16"><td>16</td><td></td><td>	&#34;unicode/utf8&#34;</td></tr>
<tr id="L17"><td>17</td><td></td><td>)</td></tr>
<tr id="L18"><td>18</td><td></td><td></td></tr>
<tr id="L19"><td>19</td><td></td><td>// FuncMap is the type of the map defining the mapping from names to functions.</td></tr>
<tr id="L20"><td>20</td><td></td><td>// Each function must have either a single return value, or two return values of</td></tr>
<tr id="L21"><td>21</td><td></td><td>// which the second has type error. In that case, if the second (error)</td></tr>
<tr id="L22"><td>22</td><td></td><td>// return value evaluates to non-nil during execution, execution terminates and</td></tr>
<tr id="L23"><td>23</td><td></td><td>// Execute returns that error.</td></tr>
<tr id="L24"><td>24</td><td></td><td>//</td></tr>
<tr id="L25"><td>25</td><td></td><td>// Errors returned by Execute wrap the underlying error; call errors.As to</td></tr>
<tr id="L26"><td>26</td><td></td><td>// uncover them.</td></tr>
<tr id="L27"><td>27</td><td></td><td>//</td></tr>
<tr id="L28"><td>28</td><td></td><td>// When template execution invokes a function with an argument list, that list</td></tr>
<tr id="L29"><td>29</td><td></td><td>// must be assignable to the function&#39;s parameter types. Functions meant to</td></tr>
<tr id="L30"><td>30</td><td></td><td>// apply to arguments of arbitrary type can use parameters of type interface{} or</td></tr>
<tr id="L31"><td>31</td><td></td><td>// of type reflect.Value. Similarly, functions meant to return a result of arbitrary</td></tr>
<tr id="L32"><td>32</td><td></td><td>// type can return interface{} or reflect.Value.</td></tr>
<tr id="L33"><td>33</td><td></td><td>type FuncMap map[string]any</td></tr>
<tr id="L34"><td>34</td><td></td><td></td></tr>
<tr id="L35"><td>35</td><td></td><td>// builtins returns the FuncMap.</td></tr>
<tr id="L36"><td>36</td><td></td><td>// It is not a global variable so the linker can dead code eliminate</td></tr>
<tr id="L37"><td>37</td><td></td><td>// more when this isn&#39;t called. See golang.org/issue/36021.</td></tr>
<tr id="L38"><td>38</td><td></td><td>// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</td></tr>
<tr id="L39" class="hit"><td>39</td><td>1</td><td>func builtins() FuncMap {</td></tr>
<tr id="L40" class="hit"><td>40</td><td>1</td><td>	return FuncMap{</td></tr>
<tr id="L41" class="hit"><td>41</td><td>1</td><td>		&#34;and&#34;:      and,</td></tr>
<tr id="L42" class="hit"><td>42</td><td>1</td><td>		&#34;call&#34;:     call,</td></tr>
<tr id="L43" class="hit"><td>43</td><td>1</td><td>		&#34;html&#34;:     HTMLEscaper,</td></tr>
<tr id="L44" class="hit"><td>44</td><td>1</td><td>		&#34;index&#34;:    index,</td></tr>
<tr id="L45" class="hit"><td>45</td><td>1</td><td>		&#34;slice&#34;:    slice,</td></tr>
<tr id="L46" class="hit"><td>46</td><td>1</td><td>		&#34;js&#34;:       JSEscaper,</td></tr>
<tr id="L47" class="hit"><td>47</td><td>1</td><td>		&#34;len&#34;:      length,</td></tr>
<tr id="L48" class="hit"><td>48</td><td>1</td><td>		&#34;not&#34;:      not,</td></tr>
<tr id="L49" class="hit"><td>49</td><td>1</td><td>		&#34;or&#34;:       or,</td></tr>
<tr id="L50" class="hit"><td>50</td><td>1</td><td>		&#34;print&#34;:    fmt.Sprint,</td></tr>
<tr id="L51" class="hit"><td>51</td><td>1</td><td>		&#34;printf&#34;:   fmt.Sprintf,</td></tr>
<tr id="L52" class="hit"><td>52</td><td>1</td><td>		&#34;println&#34;:  fmt.Sprintln,</td></tr>
<tr id="L53" class="hit"><td>53</td><td>1</td><td>		&#34;urlquery&#34;: URLQueryEscaper,</td></tr>
<tr id="L54" class="hit"><td>54</td><td>1</td><td></td></tr>
<tr id="L55" class="hit"><td>55</td><td>1</td><td>		// Comparisons</td></tr>
<tr id="L56" class="hit"><td>56</td><td>1</td><td>		&#34;eq&#34;: eq, // ==</td></tr>
<tr id="L57" class="hit"><td>57</td><td>1</td><td>		&#34;ge&#34;: ge, // &gt;=</td></tr>
<tr id="L58" class="hit"><td>58</td><td>1</td><td>		&#34;gt&#34;: gt, // &gt;</td></tr>
<tr id="L59" class="hit"><td>59</td><td>1</td><td>		&#34;le&#34;: le, // &lt;=</td></tr>
<tr id="L60" class="hit"><td>60</td><td>1</td><td>		&#34;lt&#34;: lt, // &lt;</td></tr>
<tr id="L61" class="hit"><td>61</td><td>1</td><td>		&#34;ne&#34;: ne, // !=</td></tr>
<tr id="L62" class="hit"><td>62</td><td>1</td><td>	}</td></tr>
<tr id="L63" class="hit"><td>63</td><td>1</td><td>}</td></tr>
<tr id="L64"><td>64</td><td></td><td></td></tr>
<tr id="L65"><td>65</td><td></td><td>var builtinFuncsOnce struct {</td></tr>
<tr id="L66"><td>66</td><td></td><td>	sync.Once</td></tr>
<tr id="L67"><td>67</td><td></td><td>	v map[string]reflect.Value</td></tr>
<tr id="L68"><td>68</td><td></td><td>}</td></tr>
<tr id="L69"><td>69</td><td></td><td></td></tr>
<tr id="L70"><td>70</td><td></td><td>// builtinFuncsOnce lazily computes &amp; caches the builtinFuncs map.</td></tr>
<tr id="L71"><td>71</td><td></td><td>// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</td></tr>
<tr id="L72" class="miss"><td>72</td><td>0</td><td>func builtinFuncs() map[string]reflect.Value {</td></tr>
<tr id="L73" class="miss"><td>73</td><td>0</td><td>	builtinFuncsOnce.Do(func() {</td></tr>
<tr id="L74" class="miss"><td>74</td><td>0</td><td>		builtinFuncsOnce.v = createValueFuncs(builtins())</td></tr>
<tr id="L75" class="miss"><td>75</td><td>0</td><td>	})</td></tr>
<tr id="L76" class="miss"><td>76</td><td>0</td><td>	return builtinFuncsOnce.v</td></tr>
<tr id="L77"><td>77</td><td></td><td>}</td></tr>
<tr id="L78"><td>78</td><td></td><td></td></tr>
<tr id="L79"><td>79</td><td></td><td>// createValueFuncs turns a FuncMap into a map[string]reflect.Value</td></tr>
<tr id="L80" class="miss"><td>80</td><td>0</td><td>func createValueFuncs(funcMap FuncMap) map[string]reflect.Value {</td></tr>
<tr id="L81" class="miss"><td>81</td><td>0</td><td>	m := make(map[string]reflect.Value)</td></tr>
<tr id="L82" class="miss"><td>82</td><td>0</td><td>	addValueFuncs(m, funcMap)</td></tr>
<tr id="L83" class="miss"><td>83</td><td>0</td><td>	return m</td></tr>
<tr id="L84" class="miss"><td>84</td><td>0</td><td>}</td></tr>
<tr id="L85"><td>85</td><td></td><td></td></tr>
<tr id="L86"><td>86</td><td></td><td>// addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.</td></tr>
<tr id="L87" class="hit"><td>87</td><td>1</td><td>func addValueFuncs(out map[string]reflect.Value, in FuncMap) {</td></tr>
<tr id="L88" class="hit"><td>88</td><td>17</td><td>	for name, fn := range in {</td></tr>
<tr id="L89" class="hit"><td>89</td><td>16</td><td>		if !goodName(name) {</td></tr>
<tr id="L90" class="miss"><td>90</td><td>0</td><td>			panic(fmt.Errorf(&#34;function name %q is not a valid identifier&#34;, name))</td></tr>
<tr id="L91"><td>91</td><td></td><td>		}</td></tr>
<tr id="L92" class="hit"><td>92</td><td>16</td><td>		v := reflect.ValueOf(fn)</td></tr>
<tr id="L93" class="hit"><td>93</td><td>16</td><td>		if v.Kind() != reflect.Func {</td></tr>
<tr id="L94" class="miss"><td>94</td><td>0</td><td>			panic(&#34;value for &#34; + name + &#34; not a function&#34;)</td></tr>
<tr id="L95"><td>95</td><td></td><td>		}</td></tr>
<tr id="L96" class="hit"><td>96</td><td>16</td><td>		if !goodFunc(v.Type()) {</td></tr>
<tr id="L97" class="miss"><td>97</td><td>0</td><td>			panic(fmt.Errorf(&#34;can&#39;t install method/function %q with %d results&#34;, name, v.Type().NumOut()))</td></tr>
<tr id="L98"><td>98</td><td></td><td>		}</td></tr>
<tr id="L99" class="hit"><td>99</td><td>16</td><td>		out[name] = v</td></tr>
<tr id="L100"><td>100</td><td></td><td>	}</td></tr>
<tr id="L101"><td>101</td><td></td><td>}</td></tr>
<tr id="L102"><td>102</td><td></td><td></td></tr>
<tr id="L103"><td>103</td><td></td><td>// addFuncs adds to values the functions in funcs. It does no checking of the input -</td></tr>
<tr id="L104"><td>104</td><td></td><td>// call addValueFuncs first.</td></tr>
<tr id="L105" class="hit"><td>105</td><td>1</td><td>func addFuncs(out, in FuncMap) {</td></tr>
<tr id="L106" class="hit"><td>106</td><td>17</td><td>	for name, fn := range in {</td></tr>
<tr id="L107" class="hit"><td>107</td><td>16</td><td>		out[name] = fn</td></tr>
<tr id="L108" class="hit"><td>108</td><td>16</td><td>	}</td></tr>
<tr id="L109"><td>109</td><td></td><td>}</td></tr>
<tr id="L110"><td>110</td><td></td><td></td></tr>
<tr id="L111"><td>111</td><td></td><td>// goodFunc reports whether the function or method has the right result signature.</td></tr>
<tr id="L112" class="hit"><td>112</td><td>21</td><td>func goodFunc(typ reflect.Type) bool {</td></tr>
<tr id="L113" class="hit"><td>113</td><td>21</td><td>	// We allow functions with 1 result or 2 results where the second is an error.</td></tr>
<tr id="L114" class="hit"><td>114</td><td>21</td><td>	switch {</td></tr>
<tr id="L115" class="hit"><td>115</td><td>21</td><td>	case typ.NumOut() == 1:</td></tr>
<tr id="L116" class="hit"><td>116</td><td>21</td><td>		return true</td></tr>
<tr id="L117" class="miss"><td>117</td><td>0</td><td>	case typ.NumOut() == 2 &amp;&amp; typ.Out(1) == errorType:</td></tr>
<tr id="L118" class="miss"><td>118</td><td>0</td><td>		return true</td></tr>
<tr id="L119"><td>119</td><td></td><td>	}</td></tr>
<tr id="L120" class="miss"><td>120</td><td>0</td><td>	return false</td></tr>
<tr id="L121"><td>121</td><td></td><td>}</td></tr>
<tr id="L122"><td>122</td><td></td><td></td></tr>
<tr id="L123"><td>123</td><td></td><td>// goodName reports whether the function name is a valid identifier.</td></tr>
<tr id="L124" class="hit"><td>124</td><td>16</td><td>func goodName(name string) bool {</td></tr>
<tr id="L125" class="hit"><td>125</td><td>16</td><td>	if name == &#34;&#34; {</td></tr>
<tr id="L126" class="miss"><td>126</td><td>0</td><td>		return false</td></tr>
<tr id="L127" class="miss"><td>127</td><td>0</td><td>	}</td></tr>
<tr id="L128" class="hit"><td>128</td><td>437</td><td>	for i, r := range name {</td></tr>
<tr id="L129" class="hit"><td>129</td><td>421</td><td>		switch {</td></tr>
<tr id="L130" class="hit"><td>130</td><td>48</td><td>		case r == &#39;_&#39;:</td></tr>
<tr id="L131" class="miss"><td>131</td><td>0</td><td>		case i == 0 &amp;&amp; !unicode.IsLetter(r):</td></tr>
<tr id="L132" class="miss"><td>132</td><td>0</td><td>			return false</td></tr>
<tr id="L133" class="miss"><td>133</td><td>0</td><td>		case !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r):</td></tr>
<tr id="L134" class="miss"><td>134</td><td>0</td><td>			return false</td></tr>
<tr id="L135"><td>135</td><td></td><td>		}</td></tr>
<tr id="L136"><td>136</td><td></td><td>	}</td></tr>
<tr id="L137" class="hit"><td>137</td><td>16</td><td>	return true</td></tr>
<tr id="L138"><td>138</td><td></td><td>}</td></tr>
<tr id="L139"><td>139</td><td></td><td></td></tr>
<tr id="L140"><td>140</td><td></td><td>// findFunction looks for a function in the template, and global map.</td></tr>
<tr id="L141" class="hit"><td>141</td><td>5</td><td>func findFunction(name string, tmpl *Template) (v reflect.Value, isBuiltin, ok bool) {</td></tr>
<tr id="L142" class="hit"><td>142</td><td>10</td><td>	if tmpl != nil &amp;&amp; tmpl.common != nil {</td></tr>
<tr id="L143" class="hit"><td>143</td><td>5</td><td>		tmpl.muFuncs.RLock()</td></tr>
<tr id="L144" class="hit"><td>144</td><td>5</td><td>		defer tmpl.muFuncs.RUnlock()</td></tr>
<tr id="L145" class="hit"><td>145</td><td>10</td><td>		if fn := tmpl.execFuncs[name]; fn.IsValid() {</td></tr>
<tr id="L146" class="hit"><td>146</td><td>5</td><td>			return fn, false, true</td></tr>
<tr id="L147" class="hit"><td>147</td><td>5</td><td>		}</td></tr>
<tr id="L148"><td>148</td><td></td><td>	}</td></tr>
<tr id="L149" class="miss"><td>149</td><td>0</td><td>	if fn := builtinFuncs()[name]; fn.IsValid() {</td></tr>
<tr id="L150" class="miss"><td>150</td><td>0</td><td>		return fn, true, true</td></tr>
<tr id="L151" class="miss"><td>151</td><td>0</td><td>	}</td></tr>
<tr id="L152" class="miss"><td>152</td><td>0</td><td>	return reflect.Value{}, false, false</td></tr>
<tr id="L153"><td>153</td><td></td><td>}</td></tr>
<tr id="L154"><td>154</td><td></td><td></td></tr>
<tr id="L155"><td>155</td><td></td><td>// prepareArg checks if value can be used as an argument of type argType, and</td></tr>
<tr id="L156"><td>156</td><td></td><td>// converts an invalid value to appropriate zero if possible.</td></tr>
<tr id="L157" class="miss"><td>157</td><td>0</td><td>func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) {</td></tr>
<tr id="L158" class="miss"><td>158</td><td>0</td><td>	if !value.IsValid() {</td></tr>
<tr id="L159" class="miss"><td>159</td><td>0</td><td>		if !canBeNil(argType) {</td></tr>
<tr id="L160" class="miss"><td>160</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;value is nil; should be of type %s&#34;, argType)</td></tr>
<tr id="L161" class="miss"><td>161</td><td>0</td><td>		}</td></tr>
<tr id="L162" class="miss"><td>162</td><td>0</td><td>		value = reflect.Zero(argType)</td></tr>
<tr id="L163"><td>163</td><td></td><td>	}</td></tr>
<tr id="L164" class="miss"><td>164</td><td>0</td><td>	if value.Type().AssignableTo(argType) {</td></tr>
<tr id="L165" class="miss"><td>165</td><td>0</td><td>		return value, nil</td></tr>
<tr id="L166" class="miss"><td>166</td><td>0</td><td>	}</td></tr>
<tr id="L167" class="miss"><td>167</td><td>0</td><td>	if intLike(value.Kind()) &amp;&amp; intLike(argType.Kind()) &amp;&amp; value.Type().ConvertibleTo(argType) {</td></tr>
<tr id="L168" class="miss"><td>168</td><td>0</td><td>		value = value.Convert(argType)</td></tr>
<tr id="L169" class="miss"><td>169</td><td>0</td><td>		return value, nil</td></tr>
<tr id="L170" class="miss"><td>170</td><td>0</td><td>	}</td></tr>
<tr id="L171" class="miss"><td>171</td><td>0</td><td>	return reflect.Value{}, fmt.Errorf(&#34;value has type %s; should be %s&#34;, value.Type(), argType)</td></tr>
<tr id="L172"><td>172</td><td></td><td>}</td></tr>
<tr id="L173"><td>173</td><td></td><td></td></tr>
<tr id="L174" class="miss"><td>174</td><td>0</td><td>func intLike(typ reflect.Kind) bool {</td></tr>
<tr id="L175" class="miss"><td>175</td><td>0</td><td>	switch typ {</td></tr>
<tr id="L176" class="miss"><td>176</td><td>0</td><td>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</td></tr>
<tr id="L177" class="miss"><td>177</td><td>0</td><td>		return true</td></tr>
<tr id="L178" class="miss"><td>178</td><td>0</td><td>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</td></tr>
<tr id="L179" class="miss"><td>179</td><td>0</td><td>		return true</td></tr>
<tr id="L180"><td>180</td><td></td><td>	}</td></tr>
<tr id="L181" class="miss"><td>181</td><td>0</td><td>	return false</td></tr>
<tr id="L182"><td>182</td><td></td><td>}</td></tr>
<tr id="L183"><td>183</td><td></td><td></td></tr>
<tr id="L184"><td>184</td><td></td><td>// indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible.</td></tr>
<tr id="L185" class="miss"><td>185</td><td>0</td><td>func indexArg(index reflect.Value, cap int) (int, error) {</td></tr>
<tr id="L186" class="miss"><td>186</td><td>0</td><td>	var x int64</td></tr>
<tr id="L187" class="miss"><td>187</td><td>0</td><td>	switch index.Kind() {</td></tr>
<tr id="L188" class="miss"><td>188</td><td>0</td><td>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</td></tr>
<tr id="L189" class="miss"><td>189</td><td>0</td><td>		x = index.Int()</td></tr>
<tr id="L190" class="miss"><td>190</td><td>0</td><td>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</td></tr>
<tr id="L191" class="miss"><td>191</td><td>0</td><td>		x = int64(index.Uint())</td></tr>
<tr id="L192" class="miss"><td>192</td><td>0</td><td>	case reflect.Invalid:</td></tr>
<tr id="L193" class="miss"><td>193</td><td>0</td><td>		return 0, fmt.Errorf(&#34;cannot index slice/array with nil&#34;)</td></tr>
<tr id="L194" class="miss"><td>194</td><td>0</td><td>	default:</td></tr>
<tr id="L195" class="miss"><td>195</td><td>0</td><td>		return 0, fmt.Errorf(&#34;cannot index slice/array with type %s&#34;, index.Type())</td></tr>
<tr id="L196"><td>196</td><td></td><td>	}</td></tr>
<tr id="L197" class="miss"><td>197</td><td>0</td><td>	if x &lt; 0 || int(x) &lt; 0 || int(x) &gt; cap {</td></tr>
<tr id="L198" class="miss"><td>198</td><td>0</td><td>		return 0, fmt.Errorf(&#34;index out of range: %d&#34;, x)</td></tr>
<tr id="L199" class="miss"><td>199</td><td>0</td><td>	}</td></tr>
<tr id="L200" class="miss"><td>200</td><td>0</td><td>	return int(x), nil</td></tr>
<tr id="L201"><td>201</td><td></td><td>}</td></tr>
<tr id="L202"><td>202</td><td></td><td></td></tr>
<tr id="L203"><td>203</td><td></td><td>// Indexing.</td></tr>
<tr id="L204"><td>204</td><td></td><td></td></tr>
<tr id="L205"><td>205</td><td></td><td>// index returns the result of indexing its first argument by the following</td></tr>
<tr id="L206"><td>206</td><td></td><td>// arguments. Thus &#34;index x 1 2 3&#34; is, in Go syntax, x[1][2][3]. Each</td></tr>
<tr id="L207"><td>207</td><td></td><td>// indexed item must be a map, slice, or array.</td></tr>
<tr id="L208" class="miss"><td>208</td><td>0</td><td>func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {</td></tr>
<tr id="L209" class="miss"><td>209</td><td>0</td><td>	item = indirectInterface(item)</td></tr>
<tr id="L210" class="miss"><td>210</td><td>0</td><td>	if !item.IsValid() {</td></tr>
<tr id="L211" class="miss"><td>211</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;index of untyped nil&#34;)</td></tr>
<tr id="L212" class="miss"><td>212</td><td>0</td><td>	}</td></tr>
<tr id="L213" class="miss"><td>213</td><td>0</td><td>	for _, index := range indexes {</td></tr>
<tr id="L214" class="miss"><td>214</td><td>0</td><td>		index = indirectInterface(index)</td></tr>
<tr id="L215" class="miss"><td>215</td><td>0</td><td>		var isNil bool</td></tr>
<tr id="L216" class="miss"><td>216</td><td>0</td><td>		if item, isNil = indirect(item); isNil {</td></tr>
<tr id="L217" class="miss"><td>217</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;index of nil pointer&#34;)</td></tr>
<tr id="L218" class="miss"><td>218</td><td>0</td><td>		}</td></tr>
<tr id="L219" class="miss"><td>219</td><td>0</td><td>		switch item.Kind() {</td></tr>
<tr id="L220" class="miss"><td>220</td><td>0</td><td>		case reflect.Array, reflect.Slice, reflect.String:</td></tr>
<tr id="L221" class="miss"><td>221</td><td>0</td><td>			x, err := indexArg(index, item.Len())</td></tr>
<tr id="L222" class="miss"><td>222</td><td>0</td><td>			if err != nil {</td></tr>
<tr id="L223" class="miss"><td>223</td><td>0</td><td>				return reflect.Value{}, err</td></tr>
<tr id="L224" class="miss"><td>224</td><td>0</td><td>			}</td></tr>
<tr id="L225" class="miss"><td>225</td><td>0</td><td>			item = item.Index(x)</td></tr>
<tr id="L226" class="miss"><td>226</td><td>0</td><td>		case reflect.Map:</td></tr>
<tr id="L227" class="miss"><td>227</td><td>0</td><td>			index, err := prepareArg(index, item.Type().Key())</td></tr>
<tr id="L228" class="miss"><td>228</td><td>0</td><td>			if err != nil {</td></tr>
<tr id="L229" class="miss"><td>229</td><td>0</td><td>				return reflect.Value{}, err</td></tr>
<tr id="L230" class="miss"><td>230</td><td>0</td><td>			}</td></tr>
<tr id="L231" class="miss"><td>231</td><td>0</td><td>			if x := item.MapIndex(index); x.IsValid() {</td></tr>
<tr id="L232" class="miss"><td>232</td><td>0</td><td>				item = x</td></tr>
<tr id="L233" class="miss"><td>233</td><td>0</td><td>			} else {</td></tr>
<tr id="L234" class="miss"><td>234</td><td>0</td><td>				item = reflect.Zero(item.Type().Elem())</td></tr>
<tr id="L235" class="miss"><td>235</td><td>0</td><td>			}</td></tr>
<tr id="L236" class="miss"><td>236</td><td>0</td><td>		case reflect.Invalid:</td></tr>
<tr id="L237" class="miss"><td>237</td><td>0</td><td>			// the loop holds invariant: item.IsValid()</td></tr>
<tr id="L238" class="miss"><td>238</td><td>0</td><td>			panic(&#34;unreachable&#34;)</td></tr>
<tr id="L239" class="miss"><td>239</td><td>0</td><td>		default:</td></tr>
<tr id="L240" class="miss"><td>240</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;can&#39;t index item of type %s&#34;, item.Type())</td></tr>
<tr id="L241"><td>241</td><td></td><td>		}</td></tr>
<tr id="L242"><td>242</td><td></td><td>	}</td></tr>
<tr id="L243" class="miss"><td>243</td><td>0</td><td>	return item, nil</td></tr>
<tr id="L244"><td>244</td><td></td><td>}</td></tr>
<tr id="L245"><td>245</td><td></td><td></td></tr>
<tr id="L246"><td>246</td><td></td><td>// Slicing.</td></tr>
<tr id="L247"><td>247</td><td></td><td></td></tr>
<tr id="L248"><td>248</td><td></td><td>// slice returns the result of slicing its first argument by the remaining</td></tr>
<tr id="L249"><td>249</td><td></td><td>// arguments. Thus &#34;slice x 1 2&#34; is, in Go syntax, x[1:2], while &#34;slice x&#34;</td></tr>
<tr id="L250"><td>250</td><td></td><td>// is x[:], &#34;slice x 1&#34; is x[1:], and &#34;slice x 1 2 3&#34; is x[1:2:3]. The first</td></tr>
<tr id="L251"><td>251</td><td></td><td>// argument must be a string, slice, or array.</td></tr>
<tr id="L252" class="miss"><td>252</td><td>0</td><td>func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {</td></tr>
<tr id="L253" class="miss"><td>253</td><td>0</td><td>	item = indirectInterface(item)</td></tr>
<tr id="L254" class="miss"><td>254</td><td>0</td><td>	if !item.IsValid() {</td></tr>
<tr id="L255" class="miss"><td>255</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;slice of untyped nil&#34;)</td></tr>
<tr id="L256" class="miss"><td>256</td><td>0</td><td>	}</td></tr>
<tr id="L257" class="miss"><td>257</td><td>0</td><td>	if len(indexes) &gt; 3 {</td></tr>
<tr id="L258" class="miss"><td>258</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;too many slice indexes: %d&#34;, len(indexes))</td></tr>
<tr id="L259" class="miss"><td>259</td><td>0</td><td>	}</td></tr>
<tr id="L260" class="miss"><td>260</td><td>0</td><td>	var cap int</td></tr>
<tr id="L261" class="miss"><td>261</td><td>0</td><td>	switch item.Kind() {</td></tr>
<tr id="L262" class="miss"><td>262</td><td>0</td><td>	case reflect.String:</td></tr>
<tr id="L263" class="miss"><td>263</td><td>0</td><td>		if len(indexes) == 3 {</td></tr>
<tr id="L264" class="miss"><td>264</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;cannot 3-index slice a string&#34;)</td></tr>
<tr id="L265" class="miss"><td>265</td><td>0</td><td>		}</td></tr>
<tr id="L266" class="miss"><td>266</td><td>0</td><td>		cap = item.Len()</td></tr>
<tr id="L267" class="miss"><td>267</td><td>0</td><td>	case reflect.Array, reflect.Slice:</td></tr>
<tr id="L268" class="miss"><td>268</td><td>0</td><td>		cap = item.Cap()</td></tr>
<tr id="L269" class="miss"><td>269</td><td>0</td><td>	default:</td></tr>
<tr id="L270" class="miss"><td>270</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;can&#39;t slice item of type %s&#34;, item.Type())</td></tr>
<tr id="L271"><td>271</td><td></td><td>	}</td></tr>
<tr id="L272"><td>272</td><td></td><td>	// set default values for cases item[:], item[i:].</td></tr>
<tr id="L273" class="miss"><td>273</td><td>0</td><td>	idx := [3]int{0, item.Len()}</td></tr>
<tr id="L274" class="miss"><td>274</td><td>0</td><td>	for i, index := range indexes {</td></tr>
<tr id="L275" class="miss"><td>275</td><td>0</td><td>		x, err := indexArg(index, cap)</td></tr>
<tr id="L276" class="miss"><td>276</td><td>0</td><td>		if err != nil {</td></tr>
<tr id="L277" class="miss"><td>277</td><td>0</td><td>			return reflect.Value{}, err</td></tr>
<tr id="L278" class="miss"><td>278</td><td>0</td><td>		}</td></tr>
<tr id="L279" class="miss"><td>279</td><td>0</td><td>		idx[i] = x</td></tr>
<tr id="L280"><td>280</td><td></td><td>	}</td></tr>
<tr id="L281"><td>281</td><td></td><td>	// given item[i:j], make sure i &lt;= j.</td></tr>
<tr id="L282" class="miss"><td>282</td><td>0</td><td>	if idx[0] &gt; idx[1] {</td></tr>
<tr id="L283" class="miss"><td>283</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;invalid slice index: %d &gt; %d&#34;, idx[0], idx[1])</td></tr>
<tr id="L284" class="miss"><td>284</td><td>0</td><td>	}</td></tr>
<tr id="L285" class="miss"><td>285</td><td>0</td><td>	if len(indexes) &lt; 3 {</td></tr>
<tr id="L286" class="miss"><td>286</td><td>0</td><td>		return item.Slice(idx[0], idx[1]), nil</td></tr>
<tr id="L287" class="miss"><td>287</td><td>0</td><td>	}</td></tr>
<tr id="L288"><td>288</td><td></td><td>	// given item[i:j:k], make sure i &lt;= j &lt;= k.</td></tr>
<tr id="L289" class="miss"><td>289</td><td>0</td><td>	if idx[1] &gt; idx[2] {</td></tr>
<tr id="L290" class="miss"><td>290</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;invalid slice index: %d &gt; %d&#34;, idx[1], idx[2])</td></tr>
<tr id="L291" class="miss"><td>291</td><td>0</td><td>	}</td></tr>
<tr id="L292" class="miss"><td>292</td><td>0</td><td>	return item.Slice3(idx[0], idx[1], idx[2]), nil</td></tr>
<tr id="L293"><td>293</td><td></td><td>}</td></tr>
<tr id="L294"><td>294</td><td></td><td></td></tr>
<tr id="L295"><td>295</td><td></td><td>// Length</td></tr>
<tr id="L296"><td>296</td><td></td><td></td></tr>
<tr id="L297"><td>297</td><td></td><td>// length returns the length of the item, with an error if it has no defined length.</td></tr>
<tr id="L298" class="miss"><td>298</td><td>0</td><td>func length(item reflect.Value) (int, error) {</td></tr>
<tr id="L299" class="miss"><td>299</td><td>0</td><td>	item, isNil := indirect(item)</td></tr>
<tr id="L300" class="miss"><td>300</td><td>0</td><td>	if isNil {</td></tr>
<tr id="L301" class="miss"><td>301</td><td>0</td><td>		return 0, fmt.Errorf(&#34;len of nil pointer&#34;)</td></tr>
<tr id="L302" class="miss"><td>302</td><td>0</td><td>	}</td></tr>
<tr id="L303" class="miss"><td>303</td><td>0</td><td>	switch item.Kind() {</td></tr>
<tr id="L304" class="miss"><td>304</td><td>0</td><td>	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:</td></tr>
<tr id="L305" class="miss"><td>305</td><td>0</td><td>		return item.Len(), nil</td></tr>
<tr id="L306"><td>306</td><td></td><td>	}</td></tr>
<tr id="L307" class="miss"><td>307</td><td>0</td><td>	return 0, fmt.Errorf(&#34;len of type %s&#34;, item.Type())</td></tr>
<tr id="L308"><td>308</td><td></td><td>}</td></tr>
<tr id="L309"><td>309</td><td></td><td></td></tr>
<tr id="L310"><td>310</td><td></td><td>// Function invocation</td></tr>
<tr id="L311"><td>311</td><td></td><td></td></tr>
<tr id="L312"><td>312</td><td></td><td>// call returns the result of evaluating the first argument as a function.</td></tr>
<tr id="L313"><td>313</td><td></td><td>// The function must return 1 result, or 2 results, the second of which is an error.</td></tr>
<tr id="L314" class="miss"><td>314</td><td>0</td><td>func call(fn reflect.Value, args ...reflect.Value) (reflect.Value, error) {</td></tr>
<tr id="L315" class="miss"><td>315</td><td>0</td><td>	fn = indirectInterface(fn)</td></tr>
<tr id="L316" class="miss"><td>316</td><td>0</td><td>	if !fn.IsValid() {</td></tr>
<tr id="L317" class="miss"><td>317</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;call of nil&#34;)</td></tr>
<tr id="L318" class="miss"><td>318</td><td>0</td><td>	}</td></tr>
<tr id="L319" class="miss"><td>319</td><td>0</td><td>	typ := fn.Type()</td></tr>
<tr id="L320" class="miss"><td>320</td><td>0</td><td>	if typ.Kind() != reflect.Func {</td></tr>
<tr id="L321" class="miss"><td>321</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;non-function of type %s&#34;, typ)</td></tr>
<tr id="L322" class="miss"><td>322</td><td>0</td><td>	}</td></tr>
<tr id="L323" class="miss"><td>323</td><td>0</td><td>	if !goodFunc(typ) {</td></tr>
<tr id="L324" class="miss"><td>324</td><td>0</td><td>		return reflect.Value{}, fmt.Errorf(&#34;function called with %d args; should be 1 or 2&#34;, typ.NumOut())</td></tr>
<tr id="L325" class="miss"><td>325</td><td>0</td><td>	}</td></tr>
<tr id="L326" class="miss"><td>326</td><td>0</td><td>	numIn := typ.NumIn()</td></tr>
<tr id="L327" class="miss"><td>327</td><td>0</td><td>	var dddType reflect.Type</td></tr>
<tr id="L328" class="miss"><td>328</td><td>0</td><td>	if typ.IsVariadic() {</td></tr>
<tr id="L329" class="miss"><td>329</td><td>0</td><td>		if len(args) &lt; numIn-1 {</td></tr>
<tr id="L330" class="miss"><td>330</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;wrong number of args: got %d want at least %d&#34;, len(args), numIn-1)</td></tr>
<tr id="L331" class="miss"><td>331</td><td>0</td><td>		}</td></tr>
<tr id="L332" class="miss"><td>332</td><td>0</td><td>		dddType = typ.In(numIn - 1).Elem()</td></tr>
<tr id="L333" class="miss"><td>333</td><td>0</td><td>	} else {</td></tr>
<tr id="L334" class="miss"><td>334</td><td>0</td><td>		if len(args) != numIn {</td></tr>
<tr id="L335" class="miss"><td>335</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;wrong number of args: got %d want %d&#34;, len(args), numIn)</td></tr>
<tr id="L336" class="miss"><td>336</td><td>0</td><td>		}</td></tr>
<tr id="L337"><td>337</td><td></td><td>	}</td></tr>
<tr id="L338" class="miss"><td>338</td><td>0</td><td>	argv := make([]reflect.Value, len(args))</td></tr>
<tr id="L339" class="miss"><td>339</td><td>0</td><td>	for i, arg := range args {</td></tr>
<tr id="L340" class="miss"><td>340</td><td>0</td><td>		arg = indirectInterface(arg)</td></tr>
<tr id="L341" class="miss"><td>341</td><td>0</td><td>		// Compute the expected type. Clumsy because of variadics.</td></tr>
<tr id="L342" class="miss"><td>342</td><td>0</td><td>		argType := dddType</td></tr>
<tr id="L343" class="miss"><td>343</td><td>0</td><td>		if !typ.IsVariadic() || i &lt; numIn-1 {</td></tr>
<tr id="L344" class="miss"><td>344</td><td>0</td><td>			argType = typ.In(i)</td></tr>
<tr id="L345" class="miss"><td>345</td><td>0</td><td>		}</td></tr>
<tr id="L346"><td>346</td><td></td><td></td></tr>
<tr id="L347" class="miss"><td>347</td><td>0</td><td>		var err error</td></tr>
<tr id="L348" class="miss"><td>348</td><td>0</td><td>		if argv[i], err = prepareArg(arg, argType); err != nil {</td></tr>
<tr id="L349" class="miss"><td>349</td><td>0</td><td>			return reflect.Value{}, fmt.Errorf(&#34;arg %d: %w&#34;, i, err)</td></tr>
<tr id="L350" class="miss"><td>350</td><td>0</td><td>		}</td></tr>
<tr id="L351"><td>351</td><td></td><td>	}</td></tr>
<tr id="L352" class="miss"><td>352</td><td>0</td><td>	return safeCall(fn, argv)</td></tr>
<tr id="L353"><td>353</td><td></td><td>}</td></tr>
<tr id="L354"><td>354</td><td></td><td></td></tr>
<tr id="L355"><td>355</td><td></td><td>// safeCall runs fun.Call(args), and returns the resulting value and error, if</td></tr>
<tr id="L356"><td>356</td><td></td><td>// any. If the call panics, the panic value is returned as an error.</td></tr>
<tr id="L357" class="hit"><td>357</td><td>5</td><td>func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error) {</td></tr>
<tr id="L358" class="hit"><td>358</td><td>10</td><td>	defer func() {</td></tr>
<tr id="L359" class="hit"><td>359</td><td>5</td><td>		if r := recover(); r != nil {</td></tr>
<tr id="L360" class="miss"><td>360</td><td>0</td><td>			if e, ok := r.(error); ok {</td></tr>
<tr id="L361" class="miss"><td>361</td><td>0</td><td>				err = e</td></tr>
<tr id="L362" class="miss"><td>362</td><td>0</td><td>			} else {</td></tr>
<tr id="L363" class="miss"><td>363</td><td>0</td><td>				err = fmt.Errorf(&#34;%v&#34;, r)</td></tr>
<tr id="L364" class="miss"><td>364</td><td>0</td><td>			}</td></tr>
<tr id="L365"><td>365</td><td></td><td>		}</td></tr>
<tr id="L366"><td>366</td><td></td><td>	}()</td></tr>
<tr id="L367" class="hit"><td>367</td><td>5</td><td>	ret := fun.Call(args)</td></tr>
<tr id="L368" class="hit"><td>368</td><td>5</td><td>	if len(ret) == 2 &amp;&amp; !ret[1].IsNil() {</td></tr>
<tr id="L369" class="miss"><td>369</td><td>0</td><td>		return ret[0], ret[1].Interface().(error)</td></tr>
<tr id="L370" class="miss"><td>370</td><td>0</td><td>	}</td></tr>
<tr id="L371" class="hit"><td>371</td><td>5</td><td>	return ret[0], nil</td></tr>
<tr id="L372"><td>372</td><td></td><td>}</td></tr>
<tr id="L373"><td>373</td><td></td><td></td></tr>
<tr id="L374"><td>374</td><td></td><td>// Boolean logic.</td></tr>
<tr id="L375"><td>375</td><td></td><td></td></tr>
<tr id="L376" class="miss"><td>376</td><td>0</td><td>func truth(arg reflect.Value) bool {</td></tr>
<tr id="L377" class="miss"><td>377</td><td>0</td><td>	t, _ := isTrue(indirectInterface(arg))</td></tr>
<tr id="L378" class="miss"><td>378</td><td>0</td><td>	return t</td></tr>
<tr id="L379" class="miss"><td>379</td><td>0</td><td>}</td></tr>
<tr id="L380"><td>380</td><td></td><td></td></tr>
<tr id="L381"><td>381</td><td></td><td>// and computes the Boolean AND of its arguments, returning</td></tr>
<tr id="L382"><td>382</td><td></td><td>// the first false argument it encounters, or the last argument.</td></tr>
<tr id="L383" class="miss"><td>383</td><td>0</td><td>func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value {</td></tr>
<tr id="L384" class="miss"><td>384</td><td>0</td><td>	panic(&#34;unreachable&#34;) // implemented as a special case in evalCall</td></tr>
<tr id="L385"><td>385</td><td></td><td>}</td></tr>
<tr id="L386"><td>386</td><td></td><td></td></tr>
<tr id="L387"><td>387</td><td></td><td>// or computes the Boolean OR of its arguments, returning</td></tr>
<tr id="L388"><td>388</td><td></td><td>// the first true argument it encounters, or the last argument.</td></tr>
<tr id="L389" class="miss"><td>389</td><td>0</td><td>func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value {</td></tr>
<tr id="L390" class="miss"><td>390</td><td>0</td><td>	panic(&#34;unreachable&#34;) // implemented as a special case in evalCall</td></tr>
<tr id="L391"><td>391</td><td></td><td>}</td></tr>
<tr id="L392"><td>392</td><td></td><td></td></tr>
<tr id="L393"><td>393</td><td></td><td>// not returns the Boolean negation of its argument.</td></tr>
<tr id="L394" class="miss"><td>394</td><td>0</td><td>func not(arg reflect.Value) bool {</td></tr>
<tr id="L395" class="miss"><td>395</td><td>0</td><td>	return !truth(arg)</td></tr>
<tr id="L396" class="miss"><td>396</td><td>0</td><td>}</td></tr>
<tr id="L397"><td>397</td><td></td><td></td></tr>
<tr id="L398"><td>398</td><td></td><td>// Comparison.</td></tr>
<tr id="L399"><td>399</td><td></td><td></td></tr>
<tr id="L400"><td>400</td><td></td><td>// TODO: Perhaps allow comparison between signed and unsigned integers.</td></tr>
<tr id="L401"><td>401</td><td></td><td></td></tr>
<tr id="L402"><td>402</td><td></td><td>var (</td></tr>
<tr id="L403"><td>403</td><td></td><td>	errBadComparisonType = errors.New(&#34;invalid type for comparison&#34;)</td></tr>
<tr id="L404"><td>404</td><td></td><td>	errBadComparison     = errors.New(&#34;incompatible types for comparison&#34;)</td></tr>
<tr id="L405"><td>405</td><td></td><td>	errNoComparison      = errors.New(&#34;missing argument for comparison&#34;)</td></tr>
<tr id="L406"><td>406</td><td></td><td>)</td></tr>
<tr id="L407"><td>407</td><td></td><td></td></tr>
<tr id="L408"><td>408</td><td></td><td>type kind int</td></tr>
<tr id="L409"><td>409</td><td></td><td></td></tr>
<tr id="L410"><td>410</td><td></td><td>const (</td></tr>
<tr id="L411"><td>411</td><td></td><td>	invalidKind kind = iota</td></tr>
<tr id="L412"><td>412</td><td></td><td>	boolKind</td></tr>
<tr id="L413"><td>413</td><td></td><td>	complexKind</td></tr>
<tr id="L414"><td>414</td><td></td><td>	intKind</td></tr>
<tr id="L415"><td>415</td><td></td><td>	floatKind</td></tr>
<tr id="L416"><td>416</td><td></td><td>	stringKind</td></tr>
<tr id="L417"><td>417</td><td></td><td>	uintKind</td></tr>
<tr id="L418"><td>418</td><td></td><td>)</td></tr>
<tr id="L419"><td>419</td><td></td><td></td></tr>
<tr id="L420" class="miss"><td>420</td><td>0</td><td>func basicKind(v reflect.Value) (kind, error) {</td></tr>
<tr id="L421" class="miss"><td>421</td><td>0</td><td>	switch v.Kind() {</td></tr>
<tr id="L422" class="miss"><td>422</td><td>0</td><td>	case reflect.Bool:</td></tr>
<tr id="L423" class="miss"><td>423</td><td>0</td><td>		return boolKind, nil</td></tr>
<tr id="L424" class="miss"><td>424</td><td>0</td><td>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</td></tr>
<tr id="L425" class="miss"><td>425</td><td>0</td><td>		return intKind, nil</td></tr>
<tr id="L426" class="miss"><td>426</td><td>0</td><td>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</td></tr>
<tr id="L427" class="miss"><td>427</td><td>0</td><td>		return uintKind, nil</td></tr>
<tr id="L428" class="miss"><td>428</td><td>0</td><td>	case reflect.Float32, reflect.Float64:</td></tr>
<tr id="L429" class="miss"><td>429</td><td>0</td><td>		return floatKind, nil</td></tr>
<tr id="L430" class="miss"><td>430</td><td>0</td><td>	case reflect.Complex64, reflect.Complex128:</td></tr>
<tr id="L431" class="miss"><td>431</td><td>0</td><td>		return complexKind, nil</td></tr>
<tr id="L432" class="miss"><td>432</td><td>0</td><td>	case reflect.String:</td></tr>
<tr id="L433" class="miss"><td>433</td><td>0</td><td>		return stringKind, nil</td></tr>
<tr id="L434"><td>434</td><td></td><td>	}</td></tr>
<tr id="L435" class="miss"><td>435</td><td>0</td><td>	return invalidKind, errBadComparisonType</td></tr>
<tr id="L436"><td>436</td><td></td><td>}</td></tr>
<tr id="L437"><td>437</td><td></td><td></td></tr>
<tr id="L438"><td>438</td><td></td><td>// isNil returns true if v is the zero reflect.Value, or nil of its type.</td></tr>
<tr id="L439" class="miss"><td>439</td><td>0</td><td>func isNil(v reflect.Value) bool {</td></tr>
<tr id="L440" class="miss"><td>440</td><td>0</td><td>	if !v.IsValid() {</td></tr>
<tr id="L441" class="miss"><td>441</td><td>0</td><td>		return true</td></tr>
<tr id="L442" class="miss"><td>442</td><td>0</td><td>	}</td></tr>
<tr id="L443" class="miss"><td>443</td><td>0</td><td>	switch v.Kind() {</td></tr>
<tr id="L444" class="miss"><td>444</td><td>0</td><td>	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:</td></tr>
<tr id="L445" class="miss"><td>445</td><td>0</td><td>		return v.IsNil()</td></tr>
<tr id="L446"><td>446</td><td></td><td>	}</td></tr>
<tr id="L447" class="miss"><td>447</td><td>0</td><td>	return false</td></tr>
<tr id="L448"><td>448</td><td></td><td>}</td></tr>
<tr id="L449"><td>449</td><td></td><td></td></tr>
<tr id="L450"><td>450</td><td></td><td>// canCompare reports whether v1 and v2 are both the same kind, or one is nil.</td></tr>
<tr id="L451"><td>451</td><td></td><td>// Called only when dealing with nillable types, or there&#39;s about to be an error.</td></tr>
<tr id="L452" class="miss"><td>452</td><td>0</td><td>func canCompare(v1, v2 reflect.Value) bool {</td></tr>
<tr id="L453" class="miss"><td>453</td><td>0</td><td>	k1 := v1.Kind()</td></tr>
<tr id="L454" class="miss"><td>454</td><td>0</td><td>	k2 := v2.Kind()</td></tr>
<tr id="L455" class="miss"><td>455</td><td>0</td><td>	if k1 == k2 {</td></tr>
<tr id="L456" class="miss"><td>456</td><td>0</td><td>		return true</td></tr>
<tr id="L457" class="miss"><td>457</td><td>0</td><td>	}</td></tr>
<tr id="L458"><td>458</td><td></td><td>	// We know the type can be compared to nil.</td></tr>
<tr id="L459" class="miss"><td>459</td><td>0</td><td>	return k1 == reflect.Invalid || k2 == reflect.Invalid</td></tr>
<tr id="L460"><td>460</td><td></td><td>}</td></tr>
<tr id="L461"><td>461</td><td></td><td></td></tr>
<tr id="L462"><td>462</td><td></td><td>// eq evaluates the comparison a == b || a == c || ...</td></tr>
<tr id="L463" class="miss"><td>463</td><td>0</td><td>func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error) {</td></tr>
<tr id="L464" class="miss"><td>464</td><td>0</td><td>	arg1 = indirectInterface(arg1)</td></tr>
<tr id="L465" class="miss"><td>465</td><td>0</td><td>	if len(arg2) == 0 {</td></tr>
<tr id="L466" class="miss"><td>466</td><td>0</td><td>		return false, errNoComparison</td></tr>
<tr id="L467" class="miss"><td>467</td><td>0</td><td>	}</td></tr>
<tr id="L468" class="miss"><td>468</td><td>0</td><td>	k1, _ := basicKind(arg1)</td></tr>
<tr id="L469" class="miss"><td>469</td><td>0</td><td>	for _, arg := range arg2 {</td></tr>
<tr id="L470" class="miss"><td>470</td><td>0</td><td>		arg = indirectInterface(arg)</td></tr>
<tr id="L471" class="miss"><td>471</td><td>0</td><td>		k2, _ := basicKind(arg)</td></tr>
<tr id="L472" class="miss"><td>472</td><td>0</td><td>		truth := false</td></tr>
<tr id="L473" class="miss"><td>473</td><td>0</td><td>		if k1 != k2 {</td></tr>
<tr id="L474" class="miss"><td>474</td><td>0</td><td>			// Special case: Can compare integer values regardless of type&#39;s sign.</td></tr>
<tr id="L475" class="miss"><td>475</td><td>0</td><td>			switch {</td></tr>
<tr id="L476" class="miss"><td>476</td><td>0</td><td>			case k1 == intKind &amp;&amp; k2 == uintKind:</td></tr>
<tr id="L477" class="miss"><td>477</td><td>0</td><td>				truth = arg1.Int() &gt;= 0 &amp;&amp; uint64(arg1.Int()) == arg.Uint()</td></tr>
<tr id="L478" class="miss"><td>478</td><td>0</td><td>			case k1 == uintKind &amp;&amp; k2 == intKind:</td></tr>
<tr id="L479" class="miss"><td>479</td><td>0</td><td>				truth = arg.Int() &gt;= 0 &amp;&amp; arg1.Uint() == uint64(arg.Int())</td></tr>
<tr id="L480" class="miss"><td>480</td><td>0</td><td>			default:</td></tr>
<tr id="L481" class="miss"><td>481</td><td>0</td><td>				if arg1 != zero &amp;&amp; arg != zero {</td></tr>
<tr id="L482" class="miss"><td>482</td><td>0</td><td>					return false, errBadComparison</td></tr>
<tr id="L483" class="miss"><td>483</td><td>0</td><td>				}</td></tr>
<tr id="L484"><td>484</td><td></td><td>			}</td></tr>
<tr id="L485" class="miss"><td>485</td><td>0</td><td>		} else {</td></tr>
<tr id="L486" class="miss"><td>486</td><td>0</td><td>			switch k1 {</td></tr>
<tr id="L487" class="miss"><td>487</td><td>0</td><td>			case boolKind:</td></tr>
<tr id="L488" class="miss"><td>488</td><td>0</td><td>				truth = arg1.Bool() == arg.Bool()</td></tr>
<tr id="L489" class="miss"><td>489</td><td>0</td><td>			case complexKind:</td></tr>
<tr id="L490" class="miss"><td>490</td><td>0</td><td>				truth = arg1.Complex() == arg.Complex()</td></tr>
<tr id="L491" class="miss"><td>491</td><td>0</td><td>			case floatKind:</td></tr>
<tr id="L492" class="miss"><td>492</td><td>0</td><td>				truth = arg1.Float() == arg.Float()</td></tr>
<tr id="L493" class="miss"><td>493</td><td>0</td><td>			case intKind:</td></tr>
<tr id="L494" class="miss"><td>494</td><td>0</td><td>				truth = arg1.Int() == arg.Int()</td></tr>
<tr id="L495" class="miss"><td>495</td><td>0</td><td>			case stringKind:</td></tr>
<tr id="L496" class="miss"><td>496</td><td>0</td><td>				truth = arg1.String() == arg.String()</td></tr>
<tr id="L497" class="miss"><td>497</td><td>0</td><td>			case uintKind:</td></tr>
<tr id="L498" class="miss"><td>498</td><td>0</td><td>				truth = arg1.Uint() == arg.Uint()</td></tr>
<tr id="L499" class="miss"><td>499</td><td>0</td><td>			default:</td></tr>
<tr id="L500" class="miss"><td>500</td><td>0</td><td>				if !canCompare(arg1, arg) {</td></tr>
<tr id="L501" class="miss"><td>501</td><td>0</td><td>					return false, fmt.Errorf(&#34;non-comparable types %s: %v, %s: %v&#34;, arg1, arg1.Type(), arg.Type(), arg)</td></tr>
<tr id="L502" class="miss"><td>502</td><td>0</td><td>				}</td></tr>
<tr id="L503" class="miss"><td>503</td><td>0</td><td>				if isNil(arg1) || isNil(arg) {</td></tr>
<tr id="L504" class="miss"><td>504</td><td>0</td><td>					truth = isNil(arg) == isNil(arg1)</td></tr>
<tr id="L505" class="miss"><td>505</td><td>0</td><td>				} else {</td></tr>
<tr id="L506" class="miss"><td>506</td><td>0</td><td>					if !arg.Type().Comparable() {</td></tr>
<tr id="L507" class="miss"><td>507</td><td>0</td><td>						return false, fmt.Errorf(&#34;non-comparable type %s: %v&#34;, arg, arg.Type())</td></tr>
<tr id="L508" class="miss"><td>508</td><td>0</td><td>					}</td></tr>
<tr id="L509" class="miss"><td>509</td><td>0</td><td>					truth = arg1.Interface() == arg.Interface()</td></tr>
<tr id="L510"><td>510</td><td></td><td>				}</td></tr>
<tr id="L511"><td>511</td><td></td><td>			}</td></tr>
<tr id="L512"><td>512</td><td></td><td>		}</td></tr>
<tr id="L513" class="miss"><td>513</td><td>0</td><td>		if truth {</td></tr>
<tr id="L514" class="miss"><td>514</td><td>0</td><td>			return true, nil</td></tr>
<tr id="L515" class="miss"><td>515</td><td>0</td><td>		}</td></tr>
<tr id="L516"><td>516</td><td></td><td>	}</td></tr>
<tr id="L517" class="miss"><td>517</td><td>0</td><td>	return false, nil</td></tr>
<tr id="L518"><td>518</td><td></td><td>}</td></tr>
<tr id="L519"><td>519</td><td></td><td></td></tr>
<tr id="L520"><td>520</td><td></td><td>// ne evaluates the comparison a != b.</td></tr>
<tr id="L521" class="miss"><td>521</td><td>0</td><td>func ne(arg1, arg2 reflect.Value) (bool, error) {</td></tr>
<tr id="L522" class="miss"><td>522</td><td>0</td><td>	// != is the inverse of ==.</td></tr>
<tr id="L523" class="miss"><td>523</td><td>0</td><td>	equal, err := eq(arg1, arg2)</td></tr>
<tr id="L524" class="miss"><td>524</td><td>0</td><td>	return !equal, err</td></tr>
<tr id="L525" class="miss"><td>525</td><td>0</td><td>}</td></tr>
<tr id="L526"><td>526</td><td></td><td></td></tr>
<tr id="L527"><td>527</td><td></td><td>// lt evaluates the comparison a &lt; b.</td></tr>
<tr id="L528" class="miss"><td>528</td><td>0</td><td>func lt(arg1, arg2 reflect.Value) (bool, error) {</td></tr>
<tr id="L529" class="miss"><td>529</td><td>0</td><td>	arg1 = indirectInterface(arg1)</td></tr>
<tr id="L530" class="miss"><td>530</td><td>0</td><td>	k1, err := basicKind(arg1)</td></tr>
<tr id="L531" class="miss"><td>531</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L532" class="miss"><td>532</td><td>0</td><td>		return false, err</td></tr>
<tr id="L533" class="miss"><td>533</td><td>0</td><td>	}</td></tr>
<tr id="L534" class="miss"><td>534</td><td>0</td><td>	arg2 = indirectInterface(arg2)</td></tr>
<tr id="L535" class="miss"><td>535</td><td>0</td><td>	k2, err := basicKind(arg2)</td></tr>
<tr id="L536" class="miss"><td>536</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L537" class="miss"><td>537</td><td>0</td><td>		return false, err</td></tr>
<tr id="L538" class="miss"><td>538</td><td>0</td><td>	}</td></tr>
<tr id="L539" class="miss"><td>539</td><td>0</td><td>	truth := false</td></tr>
<tr id="L540" class="miss"><td>540</td><td>0</td><td>	if k1 != k2 {</td></tr>
<tr id="L541" class="miss"><td>541</td><td>0</td><td>		// Special case: Can compare integer values regardless of type&#39;s sign.</td></tr>
<tr id="L542" class="miss"><td>542</td><td>0</td><td>		switch {</td></tr>
<tr id="L543" class="miss"><td>543</td><td>0</td><td>		case k1 == intKind &amp;&amp; k2 == uintKind:</td></tr>
<tr id="L544" class="miss"><td>544</td><td>0</td><td>			truth = arg1.Int() &lt; 0 || uint64(arg1.Int()) &lt; arg2.Uint()</td></tr>
<tr id="L545" class="miss"><td>545</td><td>0</td><td>		case k1 == uintKind &amp;&amp; k2 == intKind:</td></tr>
<tr id="L546" class="miss"><td>546</td><td>0</td><td>			truth = arg2.Int() &gt;= 0 &amp;&amp; arg1.Uint() &lt; uint64(arg2.Int())</td></tr>
<tr id="L547" class="miss"><td>547</td><td>0</td><td>		default:</td></tr>
<tr id="L548" class="miss"><td>548</td><td>0</td><td>			return false, errBadComparison</td></tr>
<tr id="L549"><td>549</td><td></td><td>		}</td></tr>
<tr id="L550" class="miss"><td>550</td><td>0</td><td>	} else {</td></tr>
<tr id="L551" class="miss"><td>551</td><td>0</td><td>		switch k1 {</td></tr>
<tr id="L552" class="miss"><td>552</td><td>0</td><td>		case boolKind, complexKind:</td></tr>
<tr id="L553" class="miss"><td>553</td><td>0</td><td>			return false, errBadComparisonType</td></tr>
<tr id="L554" class="miss"><td>554</td><td>0</td><td>		case floatKind:</td></tr>
<tr id="L555" class="miss"><td>555</td><td>0</td><td>			truth = arg1.Float() &lt; arg2.Float()</td></tr>
<tr id="L556" class="miss"><td>556</td><td>0</td><td>		case intKind:</td></tr>
<tr id="L557" class="miss"><td>557</td><td>0</td><td>			truth = arg1.Int() &lt; arg2.Int()</td></tr>
<tr id="L558" class="miss"><td>558</td><td>0</td><td>		case stringKind:</td></tr>
<tr id="L559" class="miss"><td>559</td><td>0</td><td>			truth = arg1.String() &lt; arg2.String()</td></tr>
<tr id="L560" class="miss"><td>560</td><td>0</td><td>		case uintKind:</td></tr>
<tr id="L561" class="miss"><td>561</td><td>0</td><td>			truth = arg1.Uint() &lt; arg2.Uint()</td></tr>
<tr id="L562" class="miss"><td>562</td><td>0</td><td>		default:</td></tr>
<tr id="L563" class="miss"><td>563</td><td>0</td><td>			panic(&#34;invalid kind&#34;)</td></tr>
<tr id="L564"><td>564</td><td></td><td>		}</td></tr>
<tr id="L565"><td>565</td><td></td><td>	}</td></tr>
<tr id="L566" class="miss"><td>566</td><td>0</td><td>	return truth, nil</td></tr>
<tr id="L567"><td>567</td><td></td><td>}</td></tr>
<tr id="L568"><td>568</td><td></td><td></td></tr>
<tr id="L569"><td>569</td><td></td><td>// le evaluates the comparison &lt;= b.</td></tr>
<tr id="L570" class="miss"><td>570</td><td>0</td><td>func le(arg1, arg2 reflect.Value) (bool, error) {</td></tr>
<tr id="L571" class="miss"><td>571</td><td>0</td><td>	// &lt;= is &lt; or ==.</td></tr>
<tr id="L572" class="miss"><td>572</td><td>0</td><td>	lessThan, err := lt(arg1, arg2)</td></tr>
<tr id="L573" class="miss"><td>573</td><td>0</td><td>	if lessThan || err != nil {</td></tr>
<tr id="L574" class="miss"><td>574</td><td>0</td><td>		return lessThan, err</td></tr>
<tr id="L575" class="miss"><td>575</td><td>0</td><td>	}</td></tr>
<tr id="L576" class="miss"><td>576</td><td>0</td><td>	return eq(arg1, arg2)</td></tr>
<tr id="L577"><td>577</td><td></td><td>}</td></tr>
<tr id="L578"><td>578</td><td></td><td></td></tr>
<tr id="L579"><td>579</td><td></td><td>// gt evaluates the comparison a &gt; b.</td></tr>
<tr id="L580" class="miss"><td>580</td><td>0</td><td>func gt(arg1, arg2 reflect.Value) (bool, error) {</td></tr>
<tr id="L581" class="miss"><td>581</td><td>0</td><td>	// &gt; is the inverse of &lt;=.</td></tr>
<tr id="L582" class="miss"><td>582</td><td>0</td><td>	lessOrEqual, err := le(arg1, arg2)</td></tr>
<tr id="L583" class="miss"><td>583</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L584" class="miss"><td>584</td><td>0</td><td>		return false, err</td></tr>
<tr id="L585" class="miss"><td>585</td><td>0</td><td>	}</td></tr>
<tr id="L586" class="miss"><td>586</td><td>0</td><td>	return !lessOrEqual, nil</td></tr>
<tr id="L587"><td>587</td><td></td><td>}</td></tr>
<tr id="L588"><td>588</td><td></td><td></td></tr>
<tr id="L589"><td>589</td><td></td><td>// ge evaluates the comparison a &gt;= b.</td></tr>
<tr id="L590" class="miss"><td>590</td><td>0</td><td>func ge(arg1, arg2 reflect.Value) (bool, error) {</td></tr>
<tr id="L591" class="miss"><td>591</td><td>0</td><td>	// &gt;= is the inverse of &lt;.</td></tr>
<tr id="L592" class="miss"><td>592</td><td>0</td><td>	lessThan, err := lt(arg1, arg2)</td></tr>
<tr id="L593" class="miss"><td>593</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L594" class="miss"><td>594</td><td>0</td><td>		return false, err</td></tr>
<tr id="L595" class="miss"><td>595</td><td>0</td><td>	}</td></tr>
<tr id="L596" class="miss"><td>596</td><td>0</td><td>	return !lessThan, nil</td></tr>
<tr id="L597"><td>597</td><td></td><td>}</td></tr>
<tr id="L598"><td>598</td><td></td><td></td></tr>
<tr id="L599"><td>599</td><td></td><td>// HTML escaping.</td></tr>
<tr id="L600"><td>600</td><td></td><td></td></tr>
<tr id="L601"><td>601</td><td></td><td>var (</td></tr>
<tr id="L602"><td>602</td><td></td><td>	htmlQuot = []byte(&#34;&amp;#34;&#34;) // shorter than &#34;&amp;quot;&#34;</td></tr>
<tr id="L603"><td>603</td><td></td><td>	htmlApos = []byte(&#34;&amp;#39;&#34;) // shorter than &#34;&amp;apos;&#34; and apos was not in HTML until HTML5</td></tr>
<tr id="L604"><td>604</td><td></td><td>	htmlAmp  = []byte(&#34;&amp;amp;&#34;)</td></tr>
<tr id="L605"><td>605</td><td></td><td>	htmlLt   = []byte(&#34;&amp;lt;&#34;)</td></tr>
<tr id="L606"><td>606</td><td></td><td>	htmlGt   = []byte(&#34;&amp;gt;&#34;)</td></tr>
<tr id="L607"><td>607</td><td></td><td>	htmlNull = []byte(&#34;\uFFFD&#34;)</td></tr>
<tr id="L608"><td>608</td><td></td><td>)</td></tr>
<tr id="L609"><td>609</td><td></td><td></td></tr>
<tr id="L610"><td>610</td><td></td><td>// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</td></tr>
<tr id="L611" class="miss"><td>611</td><td>0</td><td>func HTMLEscape(w io.Writer, b []byte) {</td></tr>
<tr id="L612" class="miss"><td>612</td><td>0</td><td>	last := 0</td></tr>
<tr id="L613" class="miss"><td>613</td><td>0</td><td>	for i, c := range b {</td></tr>
<tr id="L614" class="miss"><td>614</td><td>0</td><td>		var html []byte</td></tr>
<tr id="L615" class="miss"><td>615</td><td>0</td><td>		switch c {</td></tr>
<tr id="L616" class="miss"><td>616</td><td>0</td><td>		case &#39;\000&#39;:</td></tr>
<tr id="L617" class="miss"><td>617</td><td>0</td><td>			html = htmlNull</td></tr>
<tr id="L618" class="miss"><td>618</td><td>0</td><td>		case &#39;&#34;&#39;:</td></tr>
<tr id="L619" class="miss"><td>619</td><td>0</td><td>			html = htmlQuot</td></tr>
<tr id="L620" class="miss"><td>620</td><td>0</td><td>		case &#39;\&#39;&#39;:</td></tr>
<tr id="L621" class="miss"><td>621</td><td>0</td><td>			html = htmlApos</td></tr>
<tr id="L622" class="miss"><td>622</td><td>0</td><td>		case &#39;&amp;&#39;:</td></tr>
<tr id="L623" class="miss"><td>623</td><td>0</td><td>			html = htmlAmp</td></tr>
<tr id="L624" class="miss"><td>624</td><td>0</td><td>		case &#39;&lt;&#39;:</td></tr>
<tr id="L625" class="miss"><td>625</td><td>0</td><td>			html = htmlLt</td></tr>
<tr id="L626" class="miss"><td>626</td><td>0</td><td>		case &#39;&gt;&#39;:</td></tr>
<tr id="L627" class="miss"><td>627</td><td>0</td><td>			html = htmlGt</td></tr>
<tr id="L628" class="miss"><td>628</td><td>0</td><td>		default:</td></tr>
<tr id="L629" class="miss"><td>629</td><td>0</td><td>			continue</td></tr>
<tr id="L630"><td>630</td><td></td><td>		}</td></tr>
<tr id="L631" class="miss"><td>631</td><td>0</td><td>		w.Write(b[last:i])</td></tr>
<tr id="L632" class="miss"><td>632</td><td>0</td><td>		w.Write(html)</td></tr>
<tr id="L633" class="miss"><td>633</td><td>0</td><td>		last = i + 1</td></tr>
<tr id="L634"><td>634</td><td></td><td>	}</td></tr>
<tr id="L635" class="miss"><td>635</td><td>0</td><td>	w.Write(b[last:])</td></tr>
<tr id="L636"><td>636</td><td></td><td>}</td></tr>
<tr id="L637"><td>637</td><td></td><td></td></tr>
<tr id="L638"><td>638</td><td></td><td>// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</td></tr>
<tr id="L639" class="miss"><td>639</td><td>0</td><td>func HTMLEscapeString(s string) string {</td></tr>
<tr id="L640" class="miss"><td>640</td><td>0</td><td>	// Avoid allocation if we can.</td></tr>
<tr id="L641" class="miss"><td>641</td><td>0</td><td>	if !strings.ContainsAny(s, &#34;&#39;\&#34;&amp;&lt;&gt;\000&#34;) {</td></tr>
<tr id="L642" class="miss"><td>642</td><td>0</td><td>		return s</td></tr>
<tr id="L643" class="miss"><td>643</td><td>0</td><td>	}</td></tr>
<tr id="L644" class="miss"><td>644</td><td>0</td><td>	var b strings.Builder</td></tr>
<tr id="L645" class="miss"><td>645</td><td>0</td><td>	HTMLEscape(&amp;b, []byte(s))</td></tr>
<tr id="L646" class="miss"><td>646</td><td>0</td><td>	return b.String()</td></tr>
<tr id="L647"><td>647</td><td></td><td>}</td></tr>
<tr id="L648"><td>648</td><td></td><td></td></tr>
<tr id="L649"><td>649</td><td></td><td>// HTMLEscaper returns the escaped HTML equivalent of the textual</td></tr>
<tr id="L650"><td>650</td><td></td><td>// representation of its arguments.</td></tr>
<tr id="L651" class="miss"><td>651</td><td>0</td><td>func HTMLEscaper(args ...any) string {</td></tr>
<tr id="L652" class="miss"><td>652</td><td>0</td><td>	return HTMLEscapeString(evalArgs(args))</td></tr>
<tr id="L653" class="miss"><td>653</td><td>0</td><td>}</td></tr>
<tr id="L654"><td>654</td><td></td><td></td></tr>
<tr id="L655"><td>655</td><td></td><td>// JavaScript escaping.</td></tr>
<tr id="L656"><td>656</td><td></td><td></td></tr>
<tr id="L657"><td>657</td><td></td><td>var (</td></tr>
<tr id="L658"><td>658</td><td></td><td>	jsLowUni = []byte(`\u00`)</td></tr>
<tr id="L659"><td>659</td><td></td><td>	hex      = []byte(&#34;0123456789ABCDEF&#34;)</td></tr>
<tr id="L660"><td>660</td><td></td><td></td></tr>
<tr id="L661"><td>661</td><td></td><td>	jsBackslash = []byte(`\\`)</td></tr>
<tr id="L662"><td>662</td><td></td><td>	jsApos      = []byte(`\&#39;`)</td></tr>
<tr id="L663"><td>663</td><td></td><td>	jsQuot      = []byte(`\&#34;`)</td></tr>
<tr id="L664"><td>664</td><td></td><td>	jsLt        = []byte(`\u003C`)</td></tr>
<tr id="L665"><td>665</td><td></td><td>	jsGt        = []byte(`\u003E`)</td></tr>
<tr id="L666"><td>666</td><td></td><td>	jsAmp       = []byte(`\u0026`)</td></tr>
<tr id="L667"><td>667</td><td></td><td>	jsEq        = []byte(`\u003D`)</td></tr>
<tr id="L668"><td>668</td><td></td><td>)</td></tr>
<tr id="L669"><td>669</td><td></td><td></td></tr>
<tr id="L670"><td>670</td><td></td><td>// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</td></tr>
<tr id="L671" class="miss"><td>671</td><td>0</td><td>func JSEscape(w io.Writer, b []byte) {</td></tr>
<tr id="L672" class="miss"><td>672</td><td>0</td><td>	last := 0</td></tr>
<tr id="L673" class="miss"><td>673</td><td>0</td><td>	for i := 0; i &lt; len(b); i++ {</td></tr>
<tr id="L674" class="miss"><td>674</td><td>0</td><td>		c := b[i]</td></tr>
<tr id="L675" class="miss"><td>675</td><td>0</td><td></td></tr>
<tr id="L676" class="miss"><td>676</td><td>0</td><td>		if !jsIsSpecial(rune(c)) {</td></tr>
<tr id="L677" class="miss"><td>677</td><td>0</td><td>			// fast path: nothing to do</td></tr>
<tr id="L678" class="miss"><td>678</td><td>0</td><td>			continue</td></tr>
<tr id="L679"><td>679</td><td></td><td>		}</td></tr>
<tr id="L680" class="miss"><td>680</td><td>0</td><td>		w.Write(b[last:i])</td></tr>
<tr id="L681" class="miss"><td>681</td><td>0</td><td></td></tr>
<tr id="L682" class="miss"><td>682</td><td>0</td><td>		if c &lt; utf8.RuneSelf {</td></tr>
<tr id="L683" class="miss"><td>683</td><td>0</td><td>			// Quotes, slashes and angle brackets get quoted.</td></tr>
<tr id="L684" class="miss"><td>684</td><td>0</td><td>			// Control characters get written as \u00XX.</td></tr>
<tr id="L685" class="miss"><td>685</td><td>0</td><td>			switch c {</td></tr>
<tr id="L686" class="miss"><td>686</td><td>0</td><td>			case &#39;\\&#39;:</td></tr>
<tr id="L687" class="miss"><td>687</td><td>0</td><td>				w.Write(jsBackslash)</td></tr>
<tr id="L688" class="miss"><td>688</td><td>0</td><td>			case &#39;\&#39;&#39;:</td></tr>
<tr id="L689" class="miss"><td>689</td><td>0</td><td>				w.Write(jsApos)</td></tr>
<tr id="L690" class="miss"><td>690</td><td>0</td><td>			case &#39;&#34;&#39;:</td></tr>
<tr id="L691" class="miss"><td>691</td><td>0</td><td>				w.Write(jsQuot)</td></tr>
<tr id="L692" class="miss"><td>692</td><td>0</td><td>			case &#39;&lt;&#39;:</td></tr>
<tr id="L693" class="miss"><td>693</td><td>0</td><td>				w.Write(jsLt)</td></tr>
<tr id="L694" class="miss"><td>694</td><td>0</td><td>			case &#39;&gt;&#39;:</td></tr>
<tr id="L695" class="miss"><td>695</td><td>0</td><td>				w.Write(jsGt)</td></tr>
<tr id="L696" class="miss"><td>696</td><td>0</td><td>			case &#39;&amp;&#39;:</td></tr>
<tr id="L697" class="miss"><td>697</td><td>0</td><td>				w.Write(jsAmp)</td></tr>
<tr id="L698" class="miss"><td>698</td><td>0</td><td>			case &#39;=&#39;:</td></tr>
<tr id="L699" class="miss"><td>699</td><td>0</td><td>				w.Write(jsEq)</td></tr>
<tr id="L700" class="miss"><td>700</td><td>0</td><td>			default:</td></tr>
<tr id="L701" class="miss"><td>701</td><td>0</td><td>				w.Write(jsLowUni)</td></tr>
<tr id="L702" class="miss"><td>702</td><td>0</td><td>				t, b := c&gt;&gt;4, c&amp;0x0f</td></tr>
<tr id="L703" class="miss"><td>703</td><td>0</td><td>				w.Write(hex[t : t+1])</td></tr>
<tr id="L704" class="miss"><td>704</td><td>0</td><td>				w.Write(hex[b : b+1])</td></tr>
<tr id="L705"><td>705</td><td></td><td>			}</td></tr>
<tr id="L706" class="miss"><td>706</td><td>0</td><td>		} else {</td></tr>
<tr id="L707" class="miss"><td>707</td><td>0</td><td>			// Unicode rune.</td></tr>
<tr id="L708" class="miss"><td>708</td><td>0</td><td>			r, size := utf8.DecodeRune(b[i:])</td></tr>
<tr id="L709" class="miss"><td>709</td><td>0</td><td>			if unicode.IsPrint(r) {</td></tr>
<tr id="L710" class="miss"><td>710</td><td>0</td><td>				w.Write(b[i : i+size])</td></tr>
<tr id="L711" class="miss"><td>711</td><td>0</td><td>			} else {</td></tr>
<tr id="L712" class="miss"><td>712</td><td>0</td><td>				fmt.Fprintf(w, &#34;\\u%04X&#34;, r)</td></tr>
<tr id="L713" class="miss"><td>713</td><td>0</td><td>			}</td></tr>
<tr id="L714" class="miss"><td>714</td><td>0</td><td>			i += size - 1</td></tr>
<tr id="L715"><td>715</td><td></td><td>		}</td></tr>
<tr id="L716" class="miss"><td>716</td><td>0</td><td>		last = i + 1</td></tr>
<tr id="L717"><td>717</td><td></td><td>	}</td></tr>
<tr id="L718" class="miss"><td>718</td><td>0</td><td>	w.Write(b[last:])</td></tr>
<tr id="L719"><td>719</td><td></td><td>}</td></tr>
<tr id="L720"><td>720</td><td></td><td></td></tr>
<tr id="L721"><td>721</td><td></td><td>// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</td></tr>
<tr id="L722" class="miss"><td>722</td><td>0</td><td>func JSEscapeString(s string) string {</td></tr>
<tr id="L723" class="miss"><td>723</td><td>0</td><td>	// Avoid allocation if we can.</td></tr>
<tr id="L724" class="miss"><td>724</td><td>0</td><td>	if strings.IndexFunc(s, jsIsSpecial) &lt; 0 {</td></tr>
<tr id="L725" class="miss"><td>725</td><td>0</td><td>		return s</td></tr>
<tr id="L726" class="miss"><td>726</td><td>0</td><td>	}</td></tr>
<tr id="L727" class="miss"><td>727</td><td>0</td><td>	var b strings.Builder</td></tr>
<tr id="L728" class="miss"><td>728</td><td>0</td><td>	JSEscape(&amp;b, []byte(s))</td></tr>
<tr id="L729" class="miss"><td>729</td><td>0</td><td>	return b.String()</td></tr>
<tr id="L730"><td>730</td><td></td><td>}</td></tr>
<tr id="L731"><td>731</td><td></td><td></td></tr>
<tr id="L732" class="miss"><td>732</td><td>0</td><td>func jsIsSpecial(r rune) bool {</td></tr>
<tr id="L733" class="miss"><td>733</td><td>0</td><td>	switch r {</td></tr>
<tr id="L734" class="miss"><td>734</td><td>0</td><td>	case &#39;\\&#39;, &#39;\&#39;&#39;, &#39;&#34;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;=&#39;:</td></tr>
<tr id="L735" class="miss"><td>735</td><td>0</td><td>		return true</td></tr>
<tr id="L736"><td>736</td><td></td><td>	}</td></tr>
<tr id="L737" class="miss"><td>737</td><td>0</td><td>	return r &lt; &#39; &#39; || utf8.RuneSelf &lt;= r</td></tr>
<tr id="L738"><td>738</td><td></td><td>}</td></tr>
<tr id="L739"><td>739</td><td></td><td></td></tr>
<tr id="L740"><td>740</td><td></td><td>// JSEscaper returns the escaped JavaScript equivalent of the textual</td></tr>
<tr id="L741"><td>741</td><td></td><td>// representation of its arguments.</td></tr>
<tr id="L742" class="miss"><td>742</td><td>0</td><td>func JSEscaper(args ...any) string {</td></tr>
<tr id="L743" class="miss"><td>743</td><td>0</td><td>	return JSEscapeString(evalArgs(args))</td></tr>
<tr id="L744" class="miss"><td>744</td><td>0</td><td>}</td></tr>
<tr id="L745"><td>745</td><td></td><td></td></tr>
<tr id="L746"><td>746</td><td></td><td>// URLQueryEscaper returns the escaped value of the textual representation of</td></tr>
<tr id="L747"><td>747</td><td></td><td>// its arguments in a form suitable for embedding in a URL query.</td></tr>
<tr id="L748" class="miss"><td>748</td><td>0</td><td>func URLQueryEscaper(args ...any) string {</td></tr>
<tr id="L749" class="miss"><td>749</td><td>0</td><td>	return url.QueryEscape(evalArgs(args))</td></tr>
<tr id="L750" class="miss"><td>750</td><td>0</td><td>}</td></tr>
<tr id="L751"><td>751</td><td></td><td></td></tr>
<tr id="L752"><td>752</td><td></td><td>// evalArgs formats the list of arguments into a string. It is therefore equivalent to</td></tr>
<tr id="L753"><td>753</td><td></td><td>//</td></tr>
<tr id="L754"><td>754</td><td></td><td>//	fmt.Sprint(args...)</td></tr>
<tr id="L755"><td>755</td><td></td><td>//</td></tr>
<tr id="L756"><td>756</td><td></td><td>// except that each argument is indirected (if a pointer), as required,</td></tr>
<tr id="L757"><td>757</td><td></td><td>// using the same rules as the default string evaluation during template</td></tr>
<tr id="L758"><td>758</td><td></td><td>// execution.</td></tr>
<tr id="L759" class="miss"><td>759</td><td>0</td><td>func evalArgs(args []any) string {</td></tr>
<tr id="L760" class="miss"><td>760</td><td>0</td><td>	ok := false</td></tr>
<tr id="L761" class="miss"><td>761</td><td>0</td><td>	var s string</td></tr>
<tr id="L762" class="miss"><td>762</td><td>0</td><td>	// Fast path for simple common case.</td></tr>
<tr id="L763" class="miss"><td>763</td><td>0</td><td>	if len(args) == 1 {</td></tr>
<tr id="L764" class="miss"><td>764</td><td>0</td><td>		s, ok = args[0].(string)</td></tr>
<tr id="L765" class="miss"><td>765</td><td>0</td><td>	}</td></tr>
<tr id="L766" class="miss"><td>766</td><td>0</td><td>	if !ok {</td></tr>
<tr id="L767" class="miss"><td>767</td><td>0</td><td>		for i, arg := range args {</td></tr>
<tr id="L768" class="miss"><td>768</td><td>0</td><td>			a, ok := printableValue(reflect.ValueOf(arg))</td></tr>
<tr id="L769" class="miss"><td>769</td><td>0</td><td>			if ok {</td></tr>
<tr id="L770" class="miss"><td>770</td><td>0</td><td>				args[i] = a</td></tr>
<tr id="L771" class="miss"><td>771</td><td>0</td><td>			} // else let fmt do its thing</td></tr>
<tr id="L772"><td>772</td><td></td><td>		}</td></tr>
<tr id="L773" class="miss"><td>773</td><td>0</td><td>		s = fmt.Sprint(args...)</td></tr>
<tr id="L774"><td>774</td><td></td><td>	}</td></tr>
<tr id="L775" class="miss"><td>775</td><td>0</td><td>	return s</td></tr>
<tr id="L776"><td>776</td><td></td><td>}</td></tr>
</tbody></table>
</div></div>
<footer>Generated by <a href="https://gitlab.com/stone.code/scov">SCov</a>.</footer>
</body></html>