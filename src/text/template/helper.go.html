<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SCov &gt; helper.go</title>
<meta name="description" content="Code coverage report">
<meta name="generator" content="https://gitlab.com/stone.code/scov">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
<!--[if lte IE 8]>
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-old-ie-min.css">
<![endif]-->
<!--[if gt IE 8]><!-->
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css">
<!--<![endif]-->
<style>
html { padding:1em; }
body { max-width:70em; margin:auto; }
table { margin-bottom: 1em; }
.coverage { min-width:100%; }
.coverage td:nth-child(2), .coverage th:nth-child(2) { text-align:center; }
.coverage td:nth-child(3), .coverage th:nth-child(3) { text-align:center; }
.coverage td:nth-child(4), .coverage th:nth-child(4) { text-align:center; }
.sparkbar { border: 1px solid black; border-radius:1px; min-width:50px; height:1em; }
.sparkbar .fill { display: inline-block; height: 100%; }
.sparkbar .high { background-color:lightgreen; }
.sparkbar .medium { background-color:yellow; }
.sparkbar .low { background-color:red; }
.sparkbar .empty { display: inline-block; height: 1em; background-color: white; }
.source { font-family: monospace; width:100%; margin:0; }
.source th { padding: .1em .5em; text-align:left; border-bottom: 1px solid black; }
.source td { padding: .1em .5em; white-space: pre; }
.source .hit { background:lightblue; }
.source .miss { background:LightCoral; }
.source td:nth-child(1), .source th:nth-child(1) { background:PaleGoldenrod; text-align:right; }
.source td:nth-child(2), .source th:nth-child(2) { background:#f6f3d4; text-align:right; }
footer { border-top: 1px solid rgb(203, 203, 203); margin-top: 1em; background: #e0e0e0; padding: .5em 1em; }
@media screen and (min-width: 48em) {
	.pure-gutter-md > div { box-sizing: border-box; padding: 0 0.5em; }
	.pure-gutter-md > div:first-child { padding-left: 0; }
	.pure-gutter-md > div:last-child { padding-right: 0; }
}
@media screen and (max-width: 48em) {
	.table-md td, .table-md th { padding: 0.5em; }
}
</style>
</head>
<body>
<div class="pure-g"><h1 class="pure-u">SCov &gt; helper.go</h1></div>
<div class="pure-g pure-gutter-md"><div class="pure-u-1 pure-u-md-1-2">
<h2>Metadata</h2>
<table class="pure-table pure-table-horizontal">
<tr><td>Date:</td><td>Tue Mar 21 16:20:02 UTC 2023</td></tr>
<tr><td>Filename:</td><td>text/template/helper.go</td></tr>
</table>
</div><div class="pure-u-1 pure-u-md-1-2">
<h2>Coverage</h2>
<table class="pure-table pure-table-horizontal coverage">
<thead><tr><th></th><th>Hits</th><th>Total</th><th>Coverage</th></tr></thead>
<tbody>
<tr><td>Lines:</td><td>0</td><td>88</td><td>0.0%</td></tr>
<tr><td>Regions:</td><td>0</td><td>37</td><td>0.0%</td></tr>
</tbody>
</table>
</div></div>
<div class="pure-g"><div class="pure-u">
<h2>File Listing</h2>
<table class="source"><thead>
<tr><th>Line #</th><th>Hit count</th><th>Source code</th></tr>
</thead><tbody>
<tr id="L1"><td>1</td><td></td><td>// Copyright 2011 The Go Authors. All rights reserved.</td></tr>
<tr id="L2"><td>2</td><td></td><td>// Use of this source code is governed by a BSD-style</td></tr>
<tr id="L3"><td>3</td><td></td><td>// license that can be found in the LICENSE file.</td></tr>
<tr id="L4"><td>4</td><td></td><td></td></tr>
<tr id="L5"><td>5</td><td></td><td>// Helper functions to make constructing templates easier.</td></tr>
<tr id="L6"><td>6</td><td></td><td></td></tr>
<tr id="L7"><td>7</td><td></td><td>package template</td></tr>
<tr id="L8"><td>8</td><td></td><td></td></tr>
<tr id="L9"><td>9</td><td></td><td>import (</td></tr>
<tr id="L10"><td>10</td><td></td><td>	&#34;fmt&#34;</td></tr>
<tr id="L11"><td>11</td><td></td><td>	&#34;io/fs&#34;</td></tr>
<tr id="L12"><td>12</td><td></td><td>	&#34;os&#34;</td></tr>
<tr id="L13"><td>13</td><td></td><td>	&#34;path&#34;</td></tr>
<tr id="L14"><td>14</td><td></td><td>	&#34;path/filepath&#34;</td></tr>
<tr id="L15"><td>15</td><td></td><td>)</td></tr>
<tr id="L16"><td>16</td><td></td><td></td></tr>
<tr id="L17"><td>17</td><td></td><td>// Functions and methods to parse templates.</td></tr>
<tr id="L18"><td>18</td><td></td><td></td></tr>
<tr id="L19"><td>19</td><td></td><td>// Must is a helper that wraps a call to a function returning (*Template, error)</td></tr>
<tr id="L20"><td>20</td><td></td><td>// and panics if the error is non-nil. It is intended for use in variable</td></tr>
<tr id="L21"><td>21</td><td></td><td>// initializations such as</td></tr>
<tr id="L22"><td>22</td><td></td><td>//</td></tr>
<tr id="L23"><td>23</td><td></td><td>//	var t = template.Must(template.New(&#34;name&#34;).Parse(&#34;text&#34;))</td></tr>
<tr id="L24" class="miss"><td>24</td><td>0</td><td>func Must(t *Template, err error) *Template {</td></tr>
<tr id="L25" class="miss"><td>25</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L26" class="miss"><td>26</td><td>0</td><td>		panic(err)</td></tr>
<tr id="L27"><td>27</td><td></td><td>	}</td></tr>
<tr id="L28" class="miss"><td>28</td><td>0</td><td>	return t</td></tr>
<tr id="L29"><td>29</td><td></td><td>}</td></tr>
<tr id="L30"><td>30</td><td></td><td></td></tr>
<tr id="L31"><td>31</td><td></td><td>// ParseFiles creates a new Template and parses the template definitions from</td></tr>
<tr id="L32"><td>32</td><td></td><td>// the named files. The returned template&#39;s name will have the base name and</td></tr>
<tr id="L33"><td>33</td><td></td><td>// parsed contents of the first file. There must be at least one file.</td></tr>
<tr id="L34"><td>34</td><td></td><td>// If an error occurs, parsing stops and the returned *Template is nil.</td></tr>
<tr id="L35"><td>35</td><td></td><td>//</td></tr>
<tr id="L36"><td>36</td><td></td><td>// When parsing multiple files with the same name in different directories,</td></tr>
<tr id="L37"><td>37</td><td></td><td>// the last one mentioned will be the one that results.</td></tr>
<tr id="L38"><td>38</td><td></td><td>// For instance, ParseFiles(&#34;a/foo&#34;, &#34;b/foo&#34;) stores &#34;b/foo&#34; as the template</td></tr>
<tr id="L39"><td>39</td><td></td><td>// named &#34;foo&#34;, while &#34;a/foo&#34; is unavailable.</td></tr>
<tr id="L40" class="miss"><td>40</td><td>0</td><td>func ParseFiles(filenames ...string) (*Template, error) {</td></tr>
<tr id="L41" class="miss"><td>41</td><td>0</td><td>	return parseFiles(nil, readFileOS, filenames...)</td></tr>
<tr id="L42" class="miss"><td>42</td><td>0</td><td>}</td></tr>
<tr id="L43"><td>43</td><td></td><td></td></tr>
<tr id="L44"><td>44</td><td></td><td>// ParseFiles parses the named files and associates the resulting templates with</td></tr>
<tr id="L45"><td>45</td><td></td><td>// t. If an error occurs, parsing stops and the returned template is nil;</td></tr>
<tr id="L46"><td>46</td><td></td><td>// otherwise it is t. There must be at least one file.</td></tr>
<tr id="L47"><td>47</td><td></td><td>// Since the templates created by ParseFiles are named by the base</td></tr>
<tr id="L48"><td>48</td><td></td><td>// names of the argument files, t should usually have the name of one</td></tr>
<tr id="L49"><td>49</td><td></td><td>// of the (base) names of the files. If it does not, depending on t&#39;s</td></tr>
<tr id="L50"><td>50</td><td></td><td>// contents before calling ParseFiles, t.Execute may fail. In that</td></tr>
<tr id="L51"><td>51</td><td></td><td>// case use t.ExecuteTemplate to execute a valid template.</td></tr>
<tr id="L52"><td>52</td><td></td><td>//</td></tr>
<tr id="L53"><td>53</td><td></td><td>// When parsing multiple files with the same name in different directories,</td></tr>
<tr id="L54"><td>54</td><td></td><td>// the last one mentioned will be the one that results.</td></tr>
<tr id="L55" class="miss"><td>55</td><td>0</td><td>func (t *Template) ParseFiles(filenames ...string) (*Template, error) {</td></tr>
<tr id="L56" class="miss"><td>56</td><td>0</td><td>	t.init()</td></tr>
<tr id="L57" class="miss"><td>57</td><td>0</td><td>	return parseFiles(t, readFileOS, filenames...)</td></tr>
<tr id="L58" class="miss"><td>58</td><td>0</td><td>}</td></tr>
<tr id="L59"><td>59</td><td></td><td></td></tr>
<tr id="L60"><td>60</td><td></td><td>// parseFiles is the helper for the method and function. If the argument</td></tr>
<tr id="L61"><td>61</td><td></td><td>// template is nil, it is created from the first file.</td></tr>
<tr id="L62" class="miss"><td>62</td><td>0</td><td>func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error) {</td></tr>
<tr id="L63" class="miss"><td>63</td><td>0</td><td>	if len(filenames) == 0 {</td></tr>
<tr id="L64" class="miss"><td>64</td><td>0</td><td>		// Not really a problem, but be consistent.</td></tr>
<tr id="L65" class="miss"><td>65</td><td>0</td><td>		return nil, fmt.Errorf(&#34;template: no files named in call to ParseFiles&#34;)</td></tr>
<tr id="L66" class="miss"><td>66</td><td>0</td><td>	}</td></tr>
<tr id="L67" class="miss"><td>67</td><td>0</td><td>	for _, filename := range filenames {</td></tr>
<tr id="L68" class="miss"><td>68</td><td>0</td><td>		name, b, err := readFile(filename)</td></tr>
<tr id="L69" class="miss"><td>69</td><td>0</td><td>		if err != nil {</td></tr>
<tr id="L70" class="miss"><td>70</td><td>0</td><td>			return nil, err</td></tr>
<tr id="L71" class="miss"><td>71</td><td>0</td><td>		}</td></tr>
<tr id="L72" class="miss"><td>72</td><td>0</td><td>		s := string(b)</td></tr>
<tr id="L73" class="miss"><td>73</td><td>0</td><td>		// First template becomes return value if not already defined,</td></tr>
<tr id="L74" class="miss"><td>74</td><td>0</td><td>		// and we use that one for subsequent New calls to associate</td></tr>
<tr id="L75" class="miss"><td>75</td><td>0</td><td>		// all the templates together. Also, if this file has the same name</td></tr>
<tr id="L76" class="miss"><td>76</td><td>0</td><td>		// as t, this file becomes the contents of t, so</td></tr>
<tr id="L77" class="miss"><td>77</td><td>0</td><td>		//  t, err := New(name).Funcs(xxx).ParseFiles(name)</td></tr>
<tr id="L78" class="miss"><td>78</td><td>0</td><td>		// works. Otherwise we create a new template associated with t.</td></tr>
<tr id="L79" class="miss"><td>79</td><td>0</td><td>		var tmpl *Template</td></tr>
<tr id="L80" class="miss"><td>80</td><td>0</td><td>		if t == nil {</td></tr>
<tr id="L81" class="miss"><td>81</td><td>0</td><td>			t = New(name)</td></tr>
<tr id="L82" class="miss"><td>82</td><td>0</td><td>		}</td></tr>
<tr id="L83" class="miss"><td>83</td><td>0</td><td>		if name == t.Name() {</td></tr>
<tr id="L84" class="miss"><td>84</td><td>0</td><td>			tmpl = t</td></tr>
<tr id="L85" class="miss"><td>85</td><td>0</td><td>		} else {</td></tr>
<tr id="L86" class="miss"><td>86</td><td>0</td><td>			tmpl = t.New(name)</td></tr>
<tr id="L87" class="miss"><td>87</td><td>0</td><td>		}</td></tr>
<tr id="L88" class="miss"><td>88</td><td>0</td><td>		_, err = tmpl.Parse(s)</td></tr>
<tr id="L89" class="miss"><td>89</td><td>0</td><td>		if err != nil {</td></tr>
<tr id="L90" class="miss"><td>90</td><td>0</td><td>			return nil, err</td></tr>
<tr id="L91" class="miss"><td>91</td><td>0</td><td>		}</td></tr>
<tr id="L92"><td>92</td><td></td><td>	}</td></tr>
<tr id="L93" class="miss"><td>93</td><td>0</td><td>	return t, nil</td></tr>
<tr id="L94"><td>94</td><td></td><td>}</td></tr>
<tr id="L95"><td>95</td><td></td><td></td></tr>
<tr id="L96"><td>96</td><td></td><td>// ParseGlob creates a new Template and parses the template definitions from</td></tr>
<tr id="L97"><td>97</td><td></td><td>// the files identified by the pattern. The files are matched according to the</td></tr>
<tr id="L98"><td>98</td><td></td><td>// semantics of filepath.Match, and the pattern must match at least one file.</td></tr>
<tr id="L99"><td>99</td><td></td><td>// The returned template will have the (base) name and (parsed) contents of the</td></tr>
<tr id="L100"><td>100</td><td></td><td>// first file matched by the pattern. ParseGlob is equivalent to calling</td></tr>
<tr id="L101"><td>101</td><td></td><td>// ParseFiles with the list of files matched by the pattern.</td></tr>
<tr id="L102"><td>102</td><td></td><td>//</td></tr>
<tr id="L103"><td>103</td><td></td><td>// When parsing multiple files with the same name in different directories,</td></tr>
<tr id="L104"><td>104</td><td></td><td>// the last one mentioned will be the one that results.</td></tr>
<tr id="L105" class="miss"><td>105</td><td>0</td><td>func ParseGlob(pattern string) (*Template, error) {</td></tr>
<tr id="L106" class="miss"><td>106</td><td>0</td><td>	return parseGlob(nil, pattern)</td></tr>
<tr id="L107" class="miss"><td>107</td><td>0</td><td>}</td></tr>
<tr id="L108"><td>108</td><td></td><td></td></tr>
<tr id="L109"><td>109</td><td></td><td>// ParseGlob parses the template definitions in the files identified by the</td></tr>
<tr id="L110"><td>110</td><td></td><td>// pattern and associates the resulting templates with t. The files are matched</td></tr>
<tr id="L111"><td>111</td><td></td><td>// according to the semantics of filepath.Match, and the pattern must match at</td></tr>
<tr id="L112"><td>112</td><td></td><td>// least one file. ParseGlob is equivalent to calling t.ParseFiles with the</td></tr>
<tr id="L113"><td>113</td><td></td><td>// list of files matched by the pattern.</td></tr>
<tr id="L114"><td>114</td><td></td><td>//</td></tr>
<tr id="L115"><td>115</td><td></td><td>// When parsing multiple files with the same name in different directories,</td></tr>
<tr id="L116"><td>116</td><td></td><td>// the last one mentioned will be the one that results.</td></tr>
<tr id="L117" class="miss"><td>117</td><td>0</td><td>func (t *Template) ParseGlob(pattern string) (*Template, error) {</td></tr>
<tr id="L118" class="miss"><td>118</td><td>0</td><td>	t.init()</td></tr>
<tr id="L119" class="miss"><td>119</td><td>0</td><td>	return parseGlob(t, pattern)</td></tr>
<tr id="L120" class="miss"><td>120</td><td>0</td><td>}</td></tr>
<tr id="L121"><td>121</td><td></td><td></td></tr>
<tr id="L122"><td>122</td><td></td><td>// parseGlob is the implementation of the function and method ParseGlob.</td></tr>
<tr id="L123" class="miss"><td>123</td><td>0</td><td>func parseGlob(t *Template, pattern string) (*Template, error) {</td></tr>
<tr id="L124" class="miss"><td>124</td><td>0</td><td>	filenames, err := filepath.Glob(pattern)</td></tr>
<tr id="L125" class="miss"><td>125</td><td>0</td><td>	if err != nil {</td></tr>
<tr id="L126" class="miss"><td>126</td><td>0</td><td>		return nil, err</td></tr>
<tr id="L127" class="miss"><td>127</td><td>0</td><td>	}</td></tr>
<tr id="L128" class="miss"><td>128</td><td>0</td><td>	if len(filenames) == 0 {</td></tr>
<tr id="L129" class="miss"><td>129</td><td>0</td><td>		return nil, fmt.Errorf(&#34;template: pattern matches no files: %#q&#34;, pattern)</td></tr>
<tr id="L130" class="miss"><td>130</td><td>0</td><td>	}</td></tr>
<tr id="L131" class="miss"><td>131</td><td>0</td><td>	return parseFiles(t, readFileOS, filenames...)</td></tr>
<tr id="L132"><td>132</td><td></td><td>}</td></tr>
<tr id="L133"><td>133</td><td></td><td></td></tr>
<tr id="L134"><td>134</td><td></td><td>// ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys</td></tr>
<tr id="L135"><td>135</td><td></td><td>// instead of the host operating system&#39;s file system.</td></tr>
<tr id="L136"><td>136</td><td></td><td>// It accepts a list of glob patterns.</td></tr>
<tr id="L137"><td>137</td><td></td><td>// (Note that most file names serve as glob patterns matching only themselves.)</td></tr>
<tr id="L138" class="miss"><td>138</td><td>0</td><td>func ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {</td></tr>
<tr id="L139" class="miss"><td>139</td><td>0</td><td>	return parseFS(nil, fsys, patterns)</td></tr>
<tr id="L140" class="miss"><td>140</td><td>0</td><td>}</td></tr>
<tr id="L141"><td>141</td><td></td><td></td></tr>
<tr id="L142"><td>142</td><td></td><td>// ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys</td></tr>
<tr id="L143"><td>143</td><td></td><td>// instead of the host operating system&#39;s file system.</td></tr>
<tr id="L144"><td>144</td><td></td><td>// It accepts a list of glob patterns.</td></tr>
<tr id="L145"><td>145</td><td></td><td>// (Note that most file names serve as glob patterns matching only themselves.)</td></tr>
<tr id="L146" class="miss"><td>146</td><td>0</td><td>func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {</td></tr>
<tr id="L147" class="miss"><td>147</td><td>0</td><td>	t.init()</td></tr>
<tr id="L148" class="miss"><td>148</td><td>0</td><td>	return parseFS(t, fsys, patterns)</td></tr>
<tr id="L149" class="miss"><td>149</td><td>0</td><td>}</td></tr>
<tr id="L150"><td>150</td><td></td><td></td></tr>
<tr id="L151" class="miss"><td>151</td><td>0</td><td>func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error) {</td></tr>
<tr id="L152" class="miss"><td>152</td><td>0</td><td>	var filenames []string</td></tr>
<tr id="L153" class="miss"><td>153</td><td>0</td><td>	for _, pattern := range patterns {</td></tr>
<tr id="L154" class="miss"><td>154</td><td>0</td><td>		list, err := fs.Glob(fsys, pattern)</td></tr>
<tr id="L155" class="miss"><td>155</td><td>0</td><td>		if err != nil {</td></tr>
<tr id="L156" class="miss"><td>156</td><td>0</td><td>			return nil, err</td></tr>
<tr id="L157" class="miss"><td>157</td><td>0</td><td>		}</td></tr>
<tr id="L158" class="miss"><td>158</td><td>0</td><td>		if len(list) == 0 {</td></tr>
<tr id="L159" class="miss"><td>159</td><td>0</td><td>			return nil, fmt.Errorf(&#34;template: pattern matches no files: %#q&#34;, pattern)</td></tr>
<tr id="L160" class="miss"><td>160</td><td>0</td><td>		}</td></tr>
<tr id="L161" class="miss"><td>161</td><td>0</td><td>		filenames = append(filenames, list...)</td></tr>
<tr id="L162"><td>162</td><td></td><td>	}</td></tr>
<tr id="L163" class="miss"><td>163</td><td>0</td><td>	return parseFiles(t, readFileFS(fsys), filenames...)</td></tr>
<tr id="L164"><td>164</td><td></td><td>}</td></tr>
<tr id="L165"><td>165</td><td></td><td></td></tr>
<tr id="L166" class="miss"><td>166</td><td>0</td><td>func readFileOS(file string) (name string, b []byte, err error) {</td></tr>
<tr id="L167" class="miss"><td>167</td><td>0</td><td>	name = filepath.Base(file)</td></tr>
<tr id="L168" class="miss"><td>168</td><td>0</td><td>	b, err = os.ReadFile(file)</td></tr>
<tr id="L169" class="miss"><td>169</td><td>0</td><td>	return</td></tr>
<tr id="L170" class="miss"><td>170</td><td>0</td><td>}</td></tr>
<tr id="L171"><td>171</td><td></td><td></td></tr>
<tr id="L172" class="miss"><td>172</td><td>0</td><td>func readFileFS(fsys fs.FS) func(string) (string, []byte, error) {</td></tr>
<tr id="L173" class="miss"><td>173</td><td>0</td><td>	return func(file string) (name string, b []byte, err error) {</td></tr>
<tr id="L174" class="miss"><td>174</td><td>0</td><td>		name = path.Base(file)</td></tr>
<tr id="L175" class="miss"><td>175</td><td>0</td><td>		b, err = fs.ReadFile(fsys, file)</td></tr>
<tr id="L176" class="miss"><td>176</td><td>0</td><td>		return</td></tr>
<tr id="L177" class="miss"><td>177</td><td>0</td><td>	}</td></tr>
<tr id="L178"><td>178</td><td></td><td>}</td></tr>
</tbody></table>
</div></div>
<footer>Generated by <a href="https://gitlab.com/stone.code/scov">SCov</a>.</footer>
</body></html>