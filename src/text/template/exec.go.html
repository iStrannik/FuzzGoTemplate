<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SCov &gt; exec.go</title>
<meta name="description" content="Code coverage report">
<meta name="generator" content="https://gitlab.com/stone.code/scov">
<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
<!--[if lte IE 8]>
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-old-ie-min.css">
<![endif]-->
<!--[if gt IE 8]><!-->
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css">
<!--<![endif]-->
<style>
html { padding:1em; }
body { max-width:70em; margin:auto; }
table { margin-bottom: 1em; }
.coverage { min-width:100%; }
.coverage td:nth-child(2), .coverage th:nth-child(2) { text-align:center; }
.coverage td:nth-child(3), .coverage th:nth-child(3) { text-align:center; }
.coverage td:nth-child(4), .coverage th:nth-child(4) { text-align:center; }
.sparkbar { border: 1px solid black; border-radius:1px; min-width:50px; height:1em; }
.sparkbar .fill { display: inline-block; height: 100%; }
.sparkbar .high { background-color:lightgreen; }
.sparkbar .medium { background-color:yellow; }
.sparkbar .low { background-color:red; }
.sparkbar .empty { display: inline-block; height: 1em; background-color: white; }
.source { font-family: monospace; width:100%; margin:0; }
.source th { padding: .1em .5em; text-align:left; border-bottom: 1px solid black; }
.source td { padding: .1em .5em; white-space: pre; }
.source .hit { background:lightblue; }
.source .miss { background:LightCoral; }
.source td:nth-child(1), .source th:nth-child(1) { background:PaleGoldenrod; text-align:right; }
.source td:nth-child(2), .source th:nth-child(2) { background:#f6f3d4; text-align:right; }
footer { border-top: 1px solid rgb(203, 203, 203); margin-top: 1em; background: #e0e0e0; padding: .5em 1em; }
@media screen and (min-width: 48em) {
	.pure-gutter-md > div { box-sizing: border-box; padding: 0 0.5em; }
	.pure-gutter-md > div:first-child { padding-left: 0; }
	.pure-gutter-md > div:last-child { padding-right: 0; }
}
@media screen and (max-width: 48em) {
	.table-md td, .table-md th { padding: 0.5em; }
}
</style>
</head>
<body>
<div class="pure-g"><h1 class="pure-u">SCov &gt; exec.go</h1></div>
<div class="pure-g pure-gutter-md"><div class="pure-u-1 pure-u-md-1-2">
<h2>Metadata</h2>
<table class="pure-table pure-table-horizontal">
<tr><td>Date:</td><td>Mon Apr  3 08:34:00 UTC 2023</td></tr>
<tr><td>Filename:</td><td>text/template/exec.go</td></tr>
</table>
</div><div class="pure-u-1 pure-u-md-1-2">
<h2>Coverage</h2>
<table class="pure-table pure-table-horizontal coverage">
<thead><tr><th></th><th>Hits</th><th>Total</th><th>Coverage</th></tr></thead>
<tbody>
<tr><td>Lines:</td><td>158</td><td>734</td><td>21.5%</td></tr>
<tr><td>Regions:</td><td>74</td><td>350</td><td>21.1%</td></tr>
</tbody>
</table>
</div></div>
<div class="pure-g"><div class="pure-u">
<h2>File Listing</h2>
<table class="source"><thead>
<tr><th>Line #</th><th>Hit count</th><th>Source code</th></tr>
</thead><tbody>
<tr id="L1"><td>1</td><td></td><td>// Copyright 2011 The Go Authors. All rights reserved.</td></tr>
<tr id="L2"><td>2</td><td></td><td>// Use of this source code is governed by a BSD-style</td></tr>
<tr id="L3"><td>3</td><td></td><td>// license that can be found in the LICENSE file.</td></tr>
<tr id="L4"><td>4</td><td></td><td></td></tr>
<tr id="L5"><td>5</td><td></td><td>package template</td></tr>
<tr id="L6"><td>6</td><td></td><td></td></tr>
<tr id="L7"><td>7</td><td></td><td>import (</td></tr>
<tr id="L8"><td>8</td><td></td><td>	&#34;errors&#34;</td></tr>
<tr id="L9"><td>9</td><td></td><td>	&#34;fmt&#34;</td></tr>
<tr id="L10"><td>10</td><td></td><td>	&#34;internal/fmtsort&#34;</td></tr>
<tr id="L11"><td>11</td><td></td><td>	&#34;io&#34;</td></tr>
<tr id="L12"><td>12</td><td></td><td>	&#34;reflect&#34;</td></tr>
<tr id="L13"><td>13</td><td></td><td>	&#34;runtime&#34;</td></tr>
<tr id="L14"><td>14</td><td></td><td>	&#34;strings&#34;</td></tr>
<tr id="L15"><td>15</td><td></td><td>	&#34;text/template/parse&#34;</td></tr>
<tr id="L16"><td>16</td><td></td><td>)</td></tr>
<tr id="L17"><td>17</td><td></td><td></td></tr>
<tr id="L18"><td>18</td><td></td><td>// maxExecDepth specifies the maximum stack depth of templates within</td></tr>
<tr id="L19"><td>19</td><td></td><td>// templates. This limit is only practically reached by accidentally</td></tr>
<tr id="L20"><td>20</td><td></td><td>// recursive template invocations. This limit allows us to return</td></tr>
<tr id="L21"><td>21</td><td></td><td>// an error instead of triggering a stack overflow.</td></tr>
<tr id="L22"><td>22</td><td></td><td>var maxExecDepth = initMaxExecDepth()</td></tr>
<tr id="L23"><td>23</td><td></td><td></td></tr>
<tr id="L24" class="hit"><td>24</td><td>1</td><td>func initMaxExecDepth() int {</td></tr>
<tr id="L25" class="hit"><td>25</td><td>1</td><td>	if runtime.GOARCH == &#34;wasm&#34; {</td></tr>
<tr id="L26" class="miss"><td>26</td><td>0</td><td>		return 1000</td></tr>
<tr id="L27" class="miss"><td>27</td><td>0</td><td>	}</td></tr>
<tr id="L28" class="hit"><td>28</td><td>1</td><td>	return 100000</td></tr>
<tr id="L29"><td>29</td><td></td><td>}</td></tr>
<tr id="L30"><td>30</td><td></td><td></td></tr>
<tr id="L31"><td>31</td><td></td><td>// state represents the state of an execution. It&#39;s not part of the</td></tr>
<tr id="L32"><td>32</td><td></td><td>// template so that multiple executions of the same template</td></tr>
<tr id="L33"><td>33</td><td></td><td>// can execute in parallel.</td></tr>
<tr id="L34"><td>34</td><td></td><td>type state struct {</td></tr>
<tr id="L35"><td>35</td><td></td><td>	tmpl  *Template</td></tr>
<tr id="L36"><td>36</td><td></td><td>	wr    io.Writer</td></tr>
<tr id="L37"><td>37</td><td></td><td>	node  parse.Node // current node, for errors</td></tr>
<tr id="L38"><td>38</td><td></td><td>	vars  []variable // push-down stack of variable values.</td></tr>
<tr id="L39"><td>39</td><td></td><td>	depth int        // the height of the stack of executing templates.</td></tr>
<tr id="L40"><td>40</td><td></td><td>}</td></tr>
<tr id="L41"><td>41</td><td></td><td></td></tr>
<tr id="L42"><td>42</td><td></td><td>// variable holds the dynamic value of a variable such as $, $x etc.</td></tr>
<tr id="L43"><td>43</td><td></td><td>type variable struct {</td></tr>
<tr id="L44"><td>44</td><td></td><td>	name  string</td></tr>
<tr id="L45"><td>45</td><td></td><td>	value reflect.Value</td></tr>
<tr id="L46"><td>46</td><td></td><td>}</td></tr>
<tr id="L47"><td>47</td><td></td><td></td></tr>
<tr id="L48"><td>48</td><td></td><td>// push pushes a new variable on the stack.</td></tr>
<tr id="L49" class="miss"><td>49</td><td>0</td><td>func (s *state) push(name string, value reflect.Value) {</td></tr>
<tr id="L50" class="miss"><td>50</td><td>0</td><td>	s.vars = append(s.vars, variable{name, value})</td></tr>
<tr id="L51" class="miss"><td>51</td><td>0</td><td>}</td></tr>
<tr id="L52"><td>52</td><td></td><td></td></tr>
<tr id="L53"><td>53</td><td></td><td>// mark returns the length of the variable stack.</td></tr>
<tr id="L54" class="miss"><td>54</td><td>0</td><td>func (s *state) mark() int {</td></tr>
<tr id="L55" class="miss"><td>55</td><td>0</td><td>	return len(s.vars)</td></tr>
<tr id="L56" class="miss"><td>56</td><td>0</td><td>}</td></tr>
<tr id="L57"><td>57</td><td></td><td></td></tr>
<tr id="L58"><td>58</td><td></td><td>// pop pops the variable stack up to the mark.</td></tr>
<tr id="L59" class="miss"><td>59</td><td>0</td><td>func (s *state) pop(mark int) {</td></tr>
<tr id="L60" class="miss"><td>60</td><td>0</td><td>	s.vars = s.vars[0:mark]</td></tr>
<tr id="L61" class="miss"><td>61</td><td>0</td><td>}</td></tr>
<tr id="L62"><td>62</td><td></td><td></td></tr>
<tr id="L63"><td>63</td><td></td><td>// setVar overwrites the last declared variable with the given name.</td></tr>
<tr id="L64"><td>64</td><td></td><td>// Used by variable assignments.</td></tr>
<tr id="L65" class="miss"><td>65</td><td>0</td><td>func (s *state) setVar(name string, value reflect.Value) {</td></tr>
<tr id="L66" class="miss"><td>66</td><td>0</td><td>	for i := s.mark() - 1; i &gt;= 0; i-- {</td></tr>
<tr id="L67" class="miss"><td>67</td><td>0</td><td>		if s.vars[i].name == name {</td></tr>
<tr id="L68" class="miss"><td>68</td><td>0</td><td>			s.vars[i].value = value</td></tr>
<tr id="L69" class="miss"><td>69</td><td>0</td><td>			return</td></tr>
<tr id="L70" class="miss"><td>70</td><td>0</td><td>		}</td></tr>
<tr id="L71"><td>71</td><td></td><td>	}</td></tr>
<tr id="L72" class="miss"><td>72</td><td>0</td><td>	s.errorf(&#34;undefined variable: %s&#34;, name)</td></tr>
<tr id="L73"><td>73</td><td></td><td>}</td></tr>
<tr id="L74"><td>74</td><td></td><td></td></tr>
<tr id="L75"><td>75</td><td></td><td>// setTopVar overwrites the top-nth variable on the stack. Used by range iterations.</td></tr>
<tr id="L76" class="miss"><td>76</td><td>0</td><td>func (s *state) setTopVar(n int, value reflect.Value) {</td></tr>
<tr id="L77" class="miss"><td>77</td><td>0</td><td>	s.vars[len(s.vars)-n].value = value</td></tr>
<tr id="L78" class="miss"><td>78</td><td>0</td><td>}</td></tr>
<tr id="L79"><td>79</td><td></td><td></td></tr>
<tr id="L80"><td>80</td><td></td><td>// varValue returns the value of the named variable.</td></tr>
<tr id="L81" class="miss"><td>81</td><td>0</td><td>func (s *state) varValue(name string) reflect.Value {</td></tr>
<tr id="L82" class="miss"><td>82</td><td>0</td><td>	for i := s.mark() - 1; i &gt;= 0; i-- {</td></tr>
<tr id="L83" class="miss"><td>83</td><td>0</td><td>		if s.vars[i].name == name {</td></tr>
<tr id="L84" class="miss"><td>84</td><td>0</td><td>			return s.vars[i].value</td></tr>
<tr id="L85" class="miss"><td>85</td><td>0</td><td>		}</td></tr>
<tr id="L86"><td>86</td><td></td><td>	}</td></tr>
<tr id="L87" class="miss"><td>87</td><td>0</td><td>	s.errorf(&#34;undefined variable: %s&#34;, name)</td></tr>
<tr id="L88" class="miss"><td>88</td><td>0</td><td>	return zero</td></tr>
<tr id="L89"><td>89</td><td></td><td>}</td></tr>
<tr id="L90"><td>90</td><td></td><td></td></tr>
<tr id="L91"><td>91</td><td></td><td>var zero reflect.Value</td></tr>
<tr id="L92"><td>92</td><td></td><td></td></tr>
<tr id="L93"><td>93</td><td></td><td>type missingValType struct{}</td></tr>
<tr id="L94"><td>94</td><td></td><td></td></tr>
<tr id="L95"><td>95</td><td></td><td>var missingVal = reflect.ValueOf(missingValType{})</td></tr>
<tr id="L96"><td>96</td><td></td><td></td></tr>
<tr id="L97"><td>97</td><td></td><td>var missingValReflectType = reflect.TypeOf(missingValType{})</td></tr>
<tr id="L98"><td>98</td><td></td><td></td></tr>
<tr id="L99" class="hit"><td>99</td><td>9</td><td>func isMissing(v reflect.Value) bool {</td></tr>
<tr id="L100" class="hit"><td>100</td><td>9</td><td>	return v.IsValid() &amp;&amp; v.Type() == missingValReflectType</td></tr>
<tr id="L101" class="hit"><td>101</td><td>9</td><td>}</td></tr>
<tr id="L102"><td>102</td><td></td><td></td></tr>
<tr id="L103"><td>103</td><td></td><td>// at marks the state to be on node n, for error reporting.</td></tr>
<tr id="L104" class="hit"><td>104</td><td>8</td><td>func (s *state) at(node parse.Node) {</td></tr>
<tr id="L105" class="hit"><td>105</td><td>8</td><td>	s.node = node</td></tr>
<tr id="L106" class="hit"><td>106</td><td>8</td><td>}</td></tr>
<tr id="L107"><td>107</td><td></td><td></td></tr>
<tr id="L108"><td>108</td><td></td><td>// doublePercent returns the string with %&#39;s replaced by %%, if necessary,</td></tr>
<tr id="L109"><td>109</td><td></td><td>// so it can be used safely inside a Printf format string.</td></tr>
<tr id="L110" class="miss"><td>110</td><td>0</td><td>func doublePercent(str string) string {</td></tr>
<tr id="L111" class="miss"><td>111</td><td>0</td><td>	return strings.ReplaceAll(str, &#34;%&#34;, &#34;%%&#34;)</td></tr>
<tr id="L112" class="miss"><td>112</td><td>0</td><td>}</td></tr>
<tr id="L113"><td>113</td><td></td><td></td></tr>
<tr id="L114"><td>114</td><td></td><td>// TODO: It would be nice if ExecError was more broken down, but</td></tr>
<tr id="L115"><td>115</td><td></td><td>// the way ErrorContext embeds the template name makes the</td></tr>
<tr id="L116"><td>116</td><td></td><td>// processing too clumsy.</td></tr>
<tr id="L117"><td>117</td><td></td><td></td></tr>
<tr id="L118"><td>118</td><td></td><td>// ExecError is the custom error type returned when Execute has an</td></tr>
<tr id="L119"><td>119</td><td></td><td>// error evaluating its template. (If a write error occurs, the actual</td></tr>
<tr id="L120"><td>120</td><td></td><td>// error is returned; it will not be of type ExecError.)</td></tr>
<tr id="L121"><td>121</td><td></td><td>type ExecError struct {</td></tr>
<tr id="L122"><td>122</td><td></td><td>	Name string // Name of template.</td></tr>
<tr id="L123"><td>123</td><td></td><td>	Err  error  // Pre-formatted error.</td></tr>
<tr id="L124"><td>124</td><td></td><td>}</td></tr>
<tr id="L125"><td>125</td><td></td><td></td></tr>
<tr id="L126" class="miss"><td>126</td><td>0</td><td>func (e ExecError) Error() string {</td></tr>
<tr id="L127" class="miss"><td>127</td><td>0</td><td>	return e.Err.Error()</td></tr>
<tr id="L128" class="miss"><td>128</td><td>0</td><td>}</td></tr>
<tr id="L129"><td>129</td><td></td><td></td></tr>
<tr id="L130" class="miss"><td>130</td><td>0</td><td>func (e ExecError) Unwrap() error {</td></tr>
<tr id="L131" class="miss"><td>131</td><td>0</td><td>	return e.Err</td></tr>
<tr id="L132" class="miss"><td>132</td><td>0</td><td>}</td></tr>
<tr id="L133"><td>133</td><td></td><td></td></tr>
<tr id="L134"><td>134</td><td></td><td>// errorf records an ExecError and terminates processing.</td></tr>
<tr id="L135" class="miss"><td>135</td><td>0</td><td>func (s *state) errorf(format string, args ...any) {</td></tr>
<tr id="L136" class="miss"><td>136</td><td>0</td><td>	name := doublePercent(s.tmpl.Name())</td></tr>
<tr id="L137" class="miss"><td>137</td><td>0</td><td>	if s.node == nil {</td></tr>
<tr id="L138" class="miss"><td>138</td><td>0</td><td>		format = fmt.Sprintf(&#34;template: %s: %s&#34;, name, format)</td></tr>
<tr id="L139" class="miss"><td>139</td><td>0</td><td>	} else {</td></tr>
<tr id="L140" class="miss"><td>140</td><td>0</td><td>		location, context := s.tmpl.ErrorContext(s.node)</td></tr>
<tr id="L141" class="miss"><td>141</td><td>0</td><td>		format = fmt.Sprintf(&#34;template: %s: executing %q at &lt;%s&gt;: %s&#34;, location, name, doublePercent(context), format)</td></tr>
<tr id="L142" class="miss"><td>142</td><td>0</td><td>	}</td></tr>
<tr id="L143" class="miss"><td>143</td><td>0</td><td>	panic(ExecError{</td></tr>
<tr id="L144" class="miss"><td>144</td><td>0</td><td>		Name: s.tmpl.Name(),</td></tr>
<tr id="L145" class="miss"><td>145</td><td>0</td><td>		Err:  fmt.Errorf(format, args...),</td></tr>
<tr id="L146" class="miss"><td>146</td><td>0</td><td>	})</td></tr>
<tr id="L147"><td>147</td><td></td><td>}</td></tr>
<tr id="L148"><td>148</td><td></td><td></td></tr>
<tr id="L149"><td>149</td><td></td><td>// writeError is the wrapper type used internally when Execute has an</td></tr>
<tr id="L150"><td>150</td><td></td><td>// error writing to its output. We strip the wrapper in errRecover.</td></tr>
<tr id="L151"><td>151</td><td></td><td>// Note that this is not an implementation of error, so it cannot escape</td></tr>
<tr id="L152"><td>152</td><td></td><td>// from the package as an error value.</td></tr>
<tr id="L153"><td>153</td><td></td><td>type writeError struct {</td></tr>
<tr id="L154"><td>154</td><td></td><td>	Err error // Original error.</td></tr>
<tr id="L155"><td>155</td><td></td><td>}</td></tr>
<tr id="L156"><td>156</td><td></td><td></td></tr>
<tr id="L157" class="miss"><td>157</td><td>0</td><td>func (s *state) writeError(err error) {</td></tr>
<tr id="L158" class="miss"><td>158</td><td>0</td><td>	panic(writeError{</td></tr>
<tr id="L159" class="miss"><td>159</td><td>0</td><td>		Err: err,</td></tr>
<tr id="L160" class="miss"><td>160</td><td>0</td><td>	})</td></tr>
<tr id="L161"><td>161</td><td></td><td>}</td></tr>
<tr id="L162"><td>162</td><td></td><td></td></tr>
<tr id="L163"><td>163</td><td></td><td>// errRecover is the handler that turns panics into returns from the top</td></tr>
<tr id="L164"><td>164</td><td></td><td>// level of Parse.</td></tr>
<tr id="L165" class="hit"><td>165</td><td>1</td><td>func errRecover(errp *error) {</td></tr>
<tr id="L166" class="hit"><td>166</td><td>1</td><td>	e := recover()</td></tr>
<tr id="L167" class="hit"><td>167</td><td>1</td><td>	if e != nil {</td></tr>
<tr id="L168" class="miss"><td>168</td><td>0</td><td>		switch err := e.(type) {</td></tr>
<tr id="L169" class="miss"><td>169</td><td>0</td><td>		case runtime.Error:</td></tr>
<tr id="L170" class="miss"><td>170</td><td>0</td><td>			panic(e)</td></tr>
<tr id="L171" class="miss"><td>171</td><td>0</td><td>		case writeError:</td></tr>
<tr id="L172" class="miss"><td>172</td><td>0</td><td>			*errp = err.Err // Strip the wrapper.</td></tr>
<tr id="L173" class="miss"><td>173</td><td>0</td><td>		case ExecError:</td></tr>
<tr id="L174" class="miss"><td>174</td><td>0</td><td>			*errp = err // Keep the wrapper.</td></tr>
<tr id="L175" class="miss"><td>175</td><td>0</td><td>		default:</td></tr>
<tr id="L176" class="miss"><td>176</td><td>0</td><td>			panic(e)</td></tr>
<tr id="L177"><td>177</td><td></td><td>		}</td></tr>
<tr id="L178"><td>178</td><td></td><td>	}</td></tr>
<tr id="L179"><td>179</td><td></td><td>}</td></tr>
<tr id="L180"><td>180</td><td></td><td></td></tr>
<tr id="L181"><td>181</td><td></td><td>// ExecuteTemplate applies the template associated with t that has the given name</td></tr>
<tr id="L182"><td>182</td><td></td><td>// to the specified data object and writes the output to wr.</td></tr>
<tr id="L183"><td>183</td><td></td><td>// If an error occurs executing the template or writing its output,</td></tr>
<tr id="L184"><td>184</td><td></td><td>// execution stops, but partial results may already have been written to</td></tr>
<tr id="L185"><td>185</td><td></td><td>// the output writer.</td></tr>
<tr id="L186"><td>186</td><td></td><td>// A template may be executed safely in parallel, although if parallel</td></tr>
<tr id="L187"><td>187</td><td></td><td>// executions share a Writer the output may be interleaved.</td></tr>
<tr id="L188" class="miss"><td>188</td><td>0</td><td>func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error {</td></tr>
<tr id="L189" class="miss"><td>189</td><td>0</td><td>	tmpl := t.Lookup(name)</td></tr>
<tr id="L190" class="miss"><td>190</td><td>0</td><td>	if tmpl == nil {</td></tr>
<tr id="L191" class="miss"><td>191</td><td>0</td><td>		return fmt.Errorf(&#34;template: no template %q associated with template %q&#34;, name, t.name)</td></tr>
<tr id="L192" class="miss"><td>192</td><td>0</td><td>	}</td></tr>
<tr id="L193" class="miss"><td>193</td><td>0</td><td>	return tmpl.Execute(wr, data)</td></tr>
<tr id="L194"><td>194</td><td></td><td>}</td></tr>
<tr id="L195"><td>195</td><td></td><td></td></tr>
<tr id="L196"><td>196</td><td></td><td>// Execute applies a parsed template to the specified data object,</td></tr>
<tr id="L197"><td>197</td><td></td><td>// and writes the output to wr.</td></tr>
<tr id="L198"><td>198</td><td></td><td>// If an error occurs executing the template or writing its output,</td></tr>
<tr id="L199"><td>199</td><td></td><td>// execution stops, but partial results may already have been written to</td></tr>
<tr id="L200"><td>200</td><td></td><td>// the output writer.</td></tr>
<tr id="L201"><td>201</td><td></td><td>// A template may be executed safely in parallel, although if parallel</td></tr>
<tr id="L202"><td>202</td><td></td><td>// executions share a Writer the output may be interleaved.</td></tr>
<tr id="L203"><td>203</td><td></td><td>//</td></tr>
<tr id="L204"><td>204</td><td></td><td>// If data is a reflect.Value, the template applies to the concrete</td></tr>
<tr id="L205"><td>205</td><td></td><td>// value that the reflect.Value holds, as in fmt.Print.</td></tr>
<tr id="L206" class="hit"><td>206</td><td>1</td><td>func (t *Template) Execute(wr io.Writer, data any) error {</td></tr>
<tr id="L207" class="hit"><td>207</td><td>1</td><td>	return t.execute(wr, data)</td></tr>
<tr id="L208" class="hit"><td>208</td><td>1</td><td>}</td></tr>
<tr id="L209"><td>209</td><td></td><td></td></tr>
<tr id="L210" class="hit"><td>210</td><td>1</td><td>func (t *Template) execute(wr io.Writer, data any) (err error) {</td></tr>
<tr id="L211" class="hit"><td>211</td><td>1</td><td>	defer errRecover(&amp;err)</td></tr>
<tr id="L212" class="hit"><td>212</td><td>1</td><td>	value, ok := data.(reflect.Value)</td></tr>
<tr id="L213" class="hit"><td>213</td><td>2</td><td>	if !ok {</td></tr>
<tr id="L214" class="hit"><td>214</td><td>1</td><td>		value = reflect.ValueOf(data)</td></tr>
<tr id="L215" class="hit"><td>215</td><td>1</td><td>	}</td></tr>
<tr id="L216" class="hit"><td>216</td><td>1</td><td>	state := &amp;state{</td></tr>
<tr id="L217" class="hit"><td>217</td><td>1</td><td>		tmpl: t,</td></tr>
<tr id="L218" class="hit"><td>218</td><td>1</td><td>		wr:   wr,</td></tr>
<tr id="L219" class="hit"><td>219</td><td>1</td><td>		vars: []variable{{&#34;$&#34;, value}},</td></tr>
<tr id="L220" class="hit"><td>220</td><td>1</td><td>	}</td></tr>
<tr id="L221" class="hit"><td>221</td><td>1</td><td>	if t.Tree == nil || t.Root == nil {</td></tr>
<tr id="L222" class="miss"><td>222</td><td>0</td><td>		state.errorf(&#34;%q is an incomplete or empty template&#34;, t.Name())</td></tr>
<tr id="L223" class="miss"><td>223</td><td>0</td><td>	}</td></tr>
<tr id="L224" class="hit"><td>224</td><td>1</td><td>	state.walk(value, t.Root)</td></tr>
<tr id="L225" class="hit"><td>225</td><td>1</td><td>	return</td></tr>
<tr id="L226"><td>226</td><td></td><td>}</td></tr>
<tr id="L227"><td>227</td><td></td><td></td></tr>
<tr id="L228"><td>228</td><td></td><td>// DefinedTemplates returns a string listing the defined templates,</td></tr>
<tr id="L229"><td>229</td><td></td><td>// prefixed by the string &#34;; defined templates are: &#34;. If there are none,</td></tr>
<tr id="L230"><td>230</td><td></td><td>// it returns the empty string. For generating an error message here</td></tr>
<tr id="L231"><td>231</td><td></td><td>// and in html/template.</td></tr>
<tr id="L232" class="miss"><td>232</td><td>0</td><td>func (t *Template) DefinedTemplates() string {</td></tr>
<tr id="L233" class="miss"><td>233</td><td>0</td><td>	if t.common == nil {</td></tr>
<tr id="L234" class="miss"><td>234</td><td>0</td><td>		return &#34;&#34;</td></tr>
<tr id="L235" class="miss"><td>235</td><td>0</td><td>	}</td></tr>
<tr id="L236" class="miss"><td>236</td><td>0</td><td>	var b strings.Builder</td></tr>
<tr id="L237" class="miss"><td>237</td><td>0</td><td>	t.muTmpl.RLock()</td></tr>
<tr id="L238" class="miss"><td>238</td><td>0</td><td>	defer t.muTmpl.RUnlock()</td></tr>
<tr id="L239" class="miss"><td>239</td><td>0</td><td>	for name, tmpl := range t.tmpl {</td></tr>
<tr id="L240" class="miss"><td>240</td><td>0</td><td>		if tmpl.Tree == nil || tmpl.Root == nil {</td></tr>
<tr id="L241" class="miss"><td>241</td><td>0</td><td>			continue</td></tr>
<tr id="L242"><td>242</td><td></td><td>		}</td></tr>
<tr id="L243" class="miss"><td>243</td><td>0</td><td>		if b.Len() == 0 {</td></tr>
<tr id="L244" class="miss"><td>244</td><td>0</td><td>			b.WriteString(&#34;; defined templates are: &#34;)</td></tr>
<tr id="L245" class="miss"><td>245</td><td>0</td><td>		} else {</td></tr>
<tr id="L246" class="miss"><td>246</td><td>0</td><td>			b.WriteString(&#34;, &#34;)</td></tr>
<tr id="L247" class="miss"><td>247</td><td>0</td><td>		}</td></tr>
<tr id="L248" class="miss"><td>248</td><td>0</td><td>		fmt.Fprintf(&amp;b, &#34;%q&#34;, name)</td></tr>
<tr id="L249"><td>249</td><td></td><td>	}</td></tr>
<tr id="L250" class="miss"><td>250</td><td>0</td><td>	return b.String()</td></tr>
<tr id="L251"><td>251</td><td></td><td>}</td></tr>
<tr id="L252"><td>252</td><td></td><td></td></tr>
<tr id="L253"><td>253</td><td></td><td>// Sentinel errors for use with panic to signal early exits from range loops.</td></tr>
<tr id="L254"><td>254</td><td></td><td>var (</td></tr>
<tr id="L255"><td>255</td><td></td><td>	walkBreak    = errors.New(&#34;break&#34;)</td></tr>
<tr id="L256"><td>256</td><td></td><td>	walkContinue = errors.New(&#34;continue&#34;)</td></tr>
<tr id="L257"><td>257</td><td></td><td>)</td></tr>
<tr id="L258"><td>258</td><td></td><td></td></tr>
<tr id="L259"><td>259</td><td></td><td>// Walk functions step through the major pieces of the template structure,</td></tr>
<tr id="L260"><td>260</td><td></td><td>// generating output as they go.</td></tr>
<tr id="L261" class="hit"><td>261</td><td>9</td><td>func (s *state) walk(dot reflect.Value, node parse.Node) {</td></tr>
<tr id="L262" class="hit"><td>262</td><td>9</td><td>	s.at(node)</td></tr>
<tr id="L263" class="hit"><td>263</td><td>9</td><td>	switch node := node.(type) {</td></tr>
<tr id="L264" class="hit"><td>264</td><td>9</td><td>	case *parse.ActionNode:</td></tr>
<tr id="L265" class="hit"><td>265</td><td>9</td><td>		// Do not pop variables so they persist until next end.</td></tr>
<tr id="L266" class="hit"><td>266</td><td>9</td><td>		// Also, if the action declares variables, don&#39;t print the result.</td></tr>
<tr id="L267" class="hit"><td>267</td><td>9</td><td>		val := s.evalPipeline(dot, node.Pipe)</td></tr>
<tr id="L268" class="hit"><td>268</td><td>18</td><td>		if len(node.Pipe.Decl) == 0 {</td></tr>
<tr id="L269" class="hit"><td>269</td><td>9</td><td>			s.printValue(node, val)</td></tr>
<tr id="L270" class="hit"><td>270</td><td>9</td><td>		}</td></tr>
<tr id="L271" class="miss"><td>271</td><td>0</td><td>	case *parse.BreakNode:</td></tr>
<tr id="L272" class="miss"><td>272</td><td>0</td><td>		panic(walkBreak)</td></tr>
<tr id="L273" class="miss"><td>273</td><td>0</td><td>	case *parse.CommentNode:</td></tr>
<tr id="L274" class="miss"><td>274</td><td>0</td><td>	case *parse.ContinueNode:</td></tr>
<tr id="L275" class="miss"><td>275</td><td>0</td><td>		panic(walkContinue)</td></tr>
<tr id="L276" class="miss"><td>276</td><td>0</td><td>	case *parse.IfNode:</td></tr>
<tr id="L277" class="miss"><td>277</td><td>0</td><td>		s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)</td></tr>
<tr id="L278" class="hit"><td>278</td><td>1</td><td>	case *parse.ListNode:</td></tr>
<tr id="L279" class="hit"><td>279</td><td>10</td><td>		for _, node := range node.Nodes {</td></tr>
<tr id="L280" class="hit"><td>280</td><td>9</td><td>			s.walk(dot, node)</td></tr>
<tr id="L281" class="hit"><td>281</td><td>9</td><td>		}</td></tr>
<tr id="L282" class="miss"><td>282</td><td>0</td><td>	case *parse.RangeNode:</td></tr>
<tr id="L283" class="miss"><td>283</td><td>0</td><td>		s.walkRange(dot, node)</td></tr>
<tr id="L284" class="miss"><td>284</td><td>0</td><td>	case *parse.TemplateNode:</td></tr>
<tr id="L285" class="miss"><td>285</td><td>0</td><td>		s.walkTemplate(dot, node)</td></tr>
<tr id="L286" class="hit"><td>286</td><td>8</td><td>	case *parse.TextNode:</td></tr>
<tr id="L287" class="hit"><td>287</td><td>8</td><td>		if _, err := s.wr.Write(node.Text); err != nil {</td></tr>
<tr id="L288" class="miss"><td>288</td><td>0</td><td>			s.writeError(err)</td></tr>
<tr id="L289" class="miss"><td>289</td><td>0</td><td>		}</td></tr>
<tr id="L290" class="miss"><td>290</td><td>0</td><td>	case *parse.WithNode:</td></tr>
<tr id="L291" class="miss"><td>291</td><td>0</td><td>		s.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)</td></tr>
<tr id="L292" class="miss"><td>292</td><td>0</td><td>	default:</td></tr>
<tr id="L293" class="miss"><td>293</td><td>0</td><td>		s.errorf(&#34;unknown node: %s&#34;, node)</td></tr>
<tr id="L294"><td>294</td><td></td><td>	}</td></tr>
<tr id="L295"><td>295</td><td></td><td>}</td></tr>
<tr id="L296"><td>296</td><td></td><td></td></tr>
<tr id="L297"><td>297</td><td></td><td>// walkIfOrWith walks an &#39;if&#39; or &#39;with&#39; node. The two control structures</td></tr>
<tr id="L298"><td>298</td><td></td><td>// are identical in behavior except that &#39;with&#39; sets dot.</td></tr>
<tr id="L299" class="miss"><td>299</td><td>0</td><td>func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) {</td></tr>
<tr id="L300" class="miss"><td>300</td><td>0</td><td>	defer s.pop(s.mark())</td></tr>
<tr id="L301" class="miss"><td>301</td><td>0</td><td>	val := s.evalPipeline(dot, pipe)</td></tr>
<tr id="L302" class="miss"><td>302</td><td>0</td><td>	truth, ok := isTrue(indirectInterface(val))</td></tr>
<tr id="L303" class="miss"><td>303</td><td>0</td><td>	if !ok {</td></tr>
<tr id="L304" class="miss"><td>304</td><td>0</td><td>		s.errorf(&#34;if/with can&#39;t use %v&#34;, val)</td></tr>
<tr id="L305" class="miss"><td>305</td><td>0</td><td>	}</td></tr>
<tr id="L306" class="miss"><td>306</td><td>0</td><td>	if truth {</td></tr>
<tr id="L307" class="miss"><td>307</td><td>0</td><td>		if typ == parse.NodeWith {</td></tr>
<tr id="L308" class="miss"><td>308</td><td>0</td><td>			s.walk(val, list)</td></tr>
<tr id="L309" class="miss"><td>309</td><td>0</td><td>		} else {</td></tr>
<tr id="L310" class="miss"><td>310</td><td>0</td><td>			s.walk(dot, list)</td></tr>
<tr id="L311" class="miss"><td>311</td><td>0</td><td>		}</td></tr>
<tr id="L312" class="miss"><td>312</td><td>0</td><td>	} else if elseList != nil {</td></tr>
<tr id="L313" class="miss"><td>313</td><td>0</td><td>		s.walk(dot, elseList)</td></tr>
<tr id="L314" class="miss"><td>314</td><td>0</td><td>	}</td></tr>
<tr id="L315"><td>315</td><td></td><td>}</td></tr>
<tr id="L316"><td>316</td><td></td><td></td></tr>
<tr id="L317"><td>317</td><td></td><td>// IsTrue reports whether the value is &#39;true&#39;, in the sense of not the zero of its type,</td></tr>
<tr id="L318"><td>318</td><td></td><td>// and whether the value has a meaningful truth value. This is the definition of</td></tr>
<tr id="L319"><td>319</td><td></td><td>// truth used by if and other such actions.</td></tr>
<tr id="L320" class="miss"><td>320</td><td>0</td><td>func IsTrue(val any) (truth, ok bool) {</td></tr>
<tr id="L321" class="miss"><td>321</td><td>0</td><td>	return isTrue(reflect.ValueOf(val))</td></tr>
<tr id="L322" class="miss"><td>322</td><td>0</td><td>}</td></tr>
<tr id="L323"><td>323</td><td></td><td></td></tr>
<tr id="L324" class="miss"><td>324</td><td>0</td><td>func isTrue(val reflect.Value) (truth, ok bool) {</td></tr>
<tr id="L325" class="miss"><td>325</td><td>0</td><td>	if !val.IsValid() {</td></tr>
<tr id="L326" class="miss"><td>326</td><td>0</td><td>		// Something like var x interface{}, never set. It&#39;s a form of nil.</td></tr>
<tr id="L327" class="miss"><td>327</td><td>0</td><td>		return false, true</td></tr>
<tr id="L328" class="miss"><td>328</td><td>0</td><td>	}</td></tr>
<tr id="L329" class="miss"><td>329</td><td>0</td><td>	switch val.Kind() {</td></tr>
<tr id="L330" class="miss"><td>330</td><td>0</td><td>	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:</td></tr>
<tr id="L331" class="miss"><td>331</td><td>0</td><td>		truth = val.Len() &gt; 0</td></tr>
<tr id="L332" class="miss"><td>332</td><td>0</td><td>	case reflect.Bool:</td></tr>
<tr id="L333" class="miss"><td>333</td><td>0</td><td>		truth = val.Bool()</td></tr>
<tr id="L334" class="miss"><td>334</td><td>0</td><td>	case reflect.Complex64, reflect.Complex128:</td></tr>
<tr id="L335" class="miss"><td>335</td><td>0</td><td>		truth = val.Complex() != 0</td></tr>
<tr id="L336" class="miss"><td>336</td><td>0</td><td>	case reflect.Chan, reflect.Func, reflect.Pointer, reflect.Interface:</td></tr>
<tr id="L337" class="miss"><td>337</td><td>0</td><td>		truth = !val.IsNil()</td></tr>
<tr id="L338" class="miss"><td>338</td><td>0</td><td>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</td></tr>
<tr id="L339" class="miss"><td>339</td><td>0</td><td>		truth = val.Int() != 0</td></tr>
<tr id="L340" class="miss"><td>340</td><td>0</td><td>	case reflect.Float32, reflect.Float64:</td></tr>
<tr id="L341" class="miss"><td>341</td><td>0</td><td>		truth = val.Float() != 0</td></tr>
<tr id="L342" class="miss"><td>342</td><td>0</td><td>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</td></tr>
<tr id="L343" class="miss"><td>343</td><td>0</td><td>		truth = val.Uint() != 0</td></tr>
<tr id="L344" class="miss"><td>344</td><td>0</td><td>	case reflect.Struct:</td></tr>
<tr id="L345" class="miss"><td>345</td><td>0</td><td>		truth = true // Struct values are always true.</td></tr>
<tr id="L346" class="miss"><td>346</td><td>0</td><td>	default:</td></tr>
<tr id="L347" class="miss"><td>347</td><td>0</td><td>		return</td></tr>
<tr id="L348"><td>348</td><td></td><td>	}</td></tr>
<tr id="L349" class="miss"><td>349</td><td>0</td><td>	return truth, true</td></tr>
<tr id="L350"><td>350</td><td></td><td>}</td></tr>
<tr id="L351"><td>351</td><td></td><td></td></tr>
<tr id="L352" class="miss"><td>352</td><td>0</td><td>func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {</td></tr>
<tr id="L353" class="miss"><td>353</td><td>0</td><td>	s.at(r)</td></tr>
<tr id="L354" class="miss"><td>354</td><td>0</td><td>	defer func() {</td></tr>
<tr id="L355" class="miss"><td>355</td><td>0</td><td>		if r := recover(); r != nil &amp;&amp; r != walkBreak {</td></tr>
<tr id="L356" class="miss"><td>356</td><td>0</td><td>			panic(r)</td></tr>
<tr id="L357"><td>357</td><td></td><td>		}</td></tr>
<tr id="L358"><td>358</td><td></td><td>	}()</td></tr>
<tr id="L359" class="miss"><td>359</td><td>0</td><td>	defer s.pop(s.mark())</td></tr>
<tr id="L360" class="miss"><td>360</td><td>0</td><td>	val, _ := indirect(s.evalPipeline(dot, r.Pipe))</td></tr>
<tr id="L361" class="miss"><td>361</td><td>0</td><td>	// mark top of stack before any variables in the body are pushed.</td></tr>
<tr id="L362" class="miss"><td>362</td><td>0</td><td>	mark := s.mark()</td></tr>
<tr id="L363" class="miss"><td>363</td><td>0</td><td>	oneIteration := func(index, elem reflect.Value) {</td></tr>
<tr id="L364" class="miss"><td>364</td><td>0</td><td>		// Set top var (lexically the second if there are two) to the element.</td></tr>
<tr id="L365" class="miss"><td>365</td><td>0</td><td>		if len(r.Pipe.Decl) &gt; 0 {</td></tr>
<tr id="L366" class="miss"><td>366</td><td>0</td><td>			if r.Pipe.IsAssign {</td></tr>
<tr id="L367" class="miss"><td>367</td><td>0</td><td>				s.setVar(r.Pipe.Decl[0].Ident[0], elem)</td></tr>
<tr id="L368" class="miss"><td>368</td><td>0</td><td>			} else {</td></tr>
<tr id="L369" class="miss"><td>369</td><td>0</td><td>				s.setTopVar(1, elem)</td></tr>
<tr id="L370" class="miss"><td>370</td><td>0</td><td>			}</td></tr>
<tr id="L371"><td>371</td><td></td><td>		}</td></tr>
<tr id="L372"><td>372</td><td></td><td>		// Set next var (lexically the first if there are two) to the index.</td></tr>
<tr id="L373" class="miss"><td>373</td><td>0</td><td>		if len(r.Pipe.Decl) &gt; 1 {</td></tr>
<tr id="L374" class="miss"><td>374</td><td>0</td><td>			if r.Pipe.IsAssign {</td></tr>
<tr id="L375" class="miss"><td>375</td><td>0</td><td>				s.setVar(r.Pipe.Decl[1].Ident[0], index)</td></tr>
<tr id="L376" class="miss"><td>376</td><td>0</td><td>			} else {</td></tr>
<tr id="L377" class="miss"><td>377</td><td>0</td><td>				s.setTopVar(2, index)</td></tr>
<tr id="L378" class="miss"><td>378</td><td>0</td><td>			}</td></tr>
<tr id="L379"><td>379</td><td></td><td>		}</td></tr>
<tr id="L380" class="miss"><td>380</td><td>0</td><td>		defer s.pop(mark)</td></tr>
<tr id="L381" class="miss"><td>381</td><td>0</td><td>		defer func() {</td></tr>
<tr id="L382" class="miss"><td>382</td><td>0</td><td>			// Consume panic(walkContinue)</td></tr>
<tr id="L383" class="miss"><td>383</td><td>0</td><td>			if r := recover(); r != nil &amp;&amp; r != walkContinue {</td></tr>
<tr id="L384" class="miss"><td>384</td><td>0</td><td>				panic(r)</td></tr>
<tr id="L385"><td>385</td><td></td><td>			}</td></tr>
<tr id="L386"><td>386</td><td></td><td>		}()</td></tr>
<tr id="L387" class="miss"><td>387</td><td>0</td><td>		s.walk(elem, r.List)</td></tr>
<tr id="L388"><td>388</td><td></td><td>	}</td></tr>
<tr id="L389" class="miss"><td>389</td><td>0</td><td>	switch val.Kind() {</td></tr>
<tr id="L390" class="miss"><td>390</td><td>0</td><td>	case reflect.Array, reflect.Slice:</td></tr>
<tr id="L391" class="miss"><td>391</td><td>0</td><td>		if val.Len() == 0 {</td></tr>
<tr id="L392" class="miss"><td>392</td><td>0</td><td>			break</td></tr>
<tr id="L393"><td>393</td><td></td><td>		}</td></tr>
<tr id="L394" class="miss"><td>394</td><td>0</td><td>		for i := 0; i &lt; val.Len(); i++ {</td></tr>
<tr id="L395" class="miss"><td>395</td><td>0</td><td>			oneIteration(reflect.ValueOf(i), val.Index(i))</td></tr>
<tr id="L396" class="miss"><td>396</td><td>0</td><td>		}</td></tr>
<tr id="L397" class="miss"><td>397</td><td>0</td><td>		return</td></tr>
<tr id="L398" class="miss"><td>398</td><td>0</td><td>	case reflect.Map:</td></tr>
<tr id="L399" class="miss"><td>399</td><td>0</td><td>		if val.Len() == 0 {</td></tr>
<tr id="L400" class="miss"><td>400</td><td>0</td><td>			break</td></tr>
<tr id="L401"><td>401</td><td></td><td>		}</td></tr>
<tr id="L402" class="miss"><td>402</td><td>0</td><td>		om := fmtsort.Sort(val)</td></tr>
<tr id="L403" class="miss"><td>403</td><td>0</td><td>		for i, key := range om.Key {</td></tr>
<tr id="L404" class="miss"><td>404</td><td>0</td><td>			oneIteration(key, om.Value[i])</td></tr>
<tr id="L405" class="miss"><td>405</td><td>0</td><td>		}</td></tr>
<tr id="L406" class="miss"><td>406</td><td>0</td><td>		return</td></tr>
<tr id="L407" class="miss"><td>407</td><td>0</td><td>	case reflect.Chan:</td></tr>
<tr id="L408" class="miss"><td>408</td><td>0</td><td>		if val.IsNil() {</td></tr>
<tr id="L409" class="miss"><td>409</td><td>0</td><td>			break</td></tr>
<tr id="L410"><td>410</td><td></td><td>		}</td></tr>
<tr id="L411" class="miss"><td>411</td><td>0</td><td>		if val.Type().ChanDir() == reflect.SendDir {</td></tr>
<tr id="L412" class="miss"><td>412</td><td>0</td><td>			s.errorf(&#34;range over send-only channel %v&#34;, val)</td></tr>
<tr id="L413" class="miss"><td>413</td><td>0</td><td>			break</td></tr>
<tr id="L414"><td>414</td><td></td><td>		}</td></tr>
<tr id="L415" class="miss"><td>415</td><td>0</td><td>		i := 0</td></tr>
<tr id="L416" class="miss"><td>416</td><td>0</td><td>		for ; ; i++ {</td></tr>
<tr id="L417" class="miss"><td>417</td><td>0</td><td>			elem, ok := val.Recv()</td></tr>
<tr id="L418" class="miss"><td>418</td><td>0</td><td>			if !ok {</td></tr>
<tr id="L419" class="miss"><td>419</td><td>0</td><td>				break</td></tr>
<tr id="L420"><td>420</td><td></td><td>			}</td></tr>
<tr id="L421" class="miss"><td>421</td><td>0</td><td>			oneIteration(reflect.ValueOf(i), elem)</td></tr>
<tr id="L422"><td>422</td><td></td><td>		}</td></tr>
<tr id="L423" class="miss"><td>423</td><td>0</td><td>		if i == 0 {</td></tr>
<tr id="L424" class="miss"><td>424</td><td>0</td><td>			break</td></tr>
<tr id="L425"><td>425</td><td></td><td>		}</td></tr>
<tr id="L426" class="miss"><td>426</td><td>0</td><td>		return</td></tr>
<tr id="L427" class="miss"><td>427</td><td>0</td><td>	case reflect.Invalid:</td></tr>
<tr id="L428" class="miss"><td>428</td><td>0</td><td>		break // An invalid value is likely a nil map, etc. and acts like an empty map.</td></tr>
<tr id="L429" class="miss"><td>429</td><td>0</td><td>	default:</td></tr>
<tr id="L430" class="miss"><td>430</td><td>0</td><td>		s.errorf(&#34;range can&#39;t iterate over %v&#34;, val)</td></tr>
<tr id="L431"><td>431</td><td></td><td>	}</td></tr>
<tr id="L432" class="miss"><td>432</td><td>0</td><td>	if r.ElseList != nil {</td></tr>
<tr id="L433" class="miss"><td>433</td><td>0</td><td>		s.walk(dot, r.ElseList)</td></tr>
<tr id="L434" class="miss"><td>434</td><td>0</td><td>	}</td></tr>
<tr id="L435"><td>435</td><td></td><td>}</td></tr>
<tr id="L436"><td>436</td><td></td><td></td></tr>
<tr id="L437" class="miss"><td>437</td><td>0</td><td>func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) {</td></tr>
<tr id="L438" class="miss"><td>438</td><td>0</td><td>	s.at(t)</td></tr>
<tr id="L439" class="miss"><td>439</td><td>0</td><td>	tmpl := s.tmpl.Lookup(t.Name)</td></tr>
<tr id="L440" class="miss"><td>440</td><td>0</td><td>	if tmpl == nil {</td></tr>
<tr id="L441" class="miss"><td>441</td><td>0</td><td>		s.errorf(&#34;template %q not defined&#34;, t.Name)</td></tr>
<tr id="L442" class="miss"><td>442</td><td>0</td><td>	}</td></tr>
<tr id="L443" class="miss"><td>443</td><td>0</td><td>	if s.depth == maxExecDepth {</td></tr>
<tr id="L444" class="miss"><td>444</td><td>0</td><td>		s.errorf(&#34;exceeded maximum template depth (%v)&#34;, maxExecDepth)</td></tr>
<tr id="L445" class="miss"><td>445</td><td>0</td><td>	}</td></tr>
<tr id="L446"><td>446</td><td></td><td>	// Variables declared by the pipeline persist.</td></tr>
<tr id="L447" class="miss"><td>447</td><td>0</td><td>	dot = s.evalPipeline(dot, t.Pipe)</td></tr>
<tr id="L448" class="miss"><td>448</td><td>0</td><td>	newState := *s</td></tr>
<tr id="L449" class="miss"><td>449</td><td>0</td><td>	newState.depth++</td></tr>
<tr id="L450" class="miss"><td>450</td><td>0</td><td>	newState.tmpl = tmpl</td></tr>
<tr id="L451" class="miss"><td>451</td><td>0</td><td>	// No dynamic scoping: template invocations inherit no variables.</td></tr>
<tr id="L452" class="miss"><td>452</td><td>0</td><td>	newState.vars = []variable{{&#34;$&#34;, dot}}</td></tr>
<tr id="L453" class="miss"><td>453</td><td>0</td><td>	newState.walk(dot, tmpl.Root)</td></tr>
<tr id="L454"><td>454</td><td></td><td>}</td></tr>
<tr id="L455"><td>455</td><td></td><td></td></tr>
<tr id="L456"><td>456</td><td></td><td>// Eval functions evaluate pipelines, commands, and their elements and extract</td></tr>
<tr id="L457"><td>457</td><td></td><td>// values from the data structure by examining fields, calling methods, and so on.</td></tr>
<tr id="L458"><td>458</td><td></td><td>// The printing of those values happens only through walk functions.</td></tr>
<tr id="L459"><td>459</td><td></td><td></td></tr>
<tr id="L460"><td>460</td><td></td><td>// evalPipeline returns the value acquired by evaluating a pipeline. If the</td></tr>
<tr id="L461"><td>461</td><td></td><td>// pipeline has a variable declaration, the variable will be pushed on the</td></tr>
<tr id="L462"><td>462</td><td></td><td>// stack. Callers should therefore pop the stack after they are finished</td></tr>
<tr id="L463"><td>463</td><td></td><td>// executing commands depending on the pipeline value.</td></tr>
<tr id="L464" class="hit"><td>464</td><td>9</td><td>func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value) {</td></tr>
<tr id="L465" class="hit"><td>465</td><td>9</td><td>	if pipe == nil {</td></tr>
<tr id="L466" class="miss"><td>466</td><td>0</td><td>		return</td></tr>
<tr id="L467" class="miss"><td>467</td><td>0</td><td>	}</td></tr>
<tr id="L468" class="hit"><td>468</td><td>9</td><td>	s.at(pipe)</td></tr>
<tr id="L469" class="hit"><td>469</td><td>9</td><td>	value = missingVal</td></tr>
<tr id="L470" class="hit"><td>470</td><td>18</td><td>	for _, cmd := range pipe.Cmds {</td></tr>
<tr id="L471" class="hit"><td>471</td><td>9</td><td>		value = s.evalCommand(dot, cmd, value) // previous value is this one&#39;s final arg.</td></tr>
<tr id="L472" class="hit"><td>472</td><td>9</td><td>		// If the object has type interface{}, dig down one level to the thing inside.</td></tr>
<tr id="L473" class="hit"><td>473</td><td>9</td><td>		if value.Kind() == reflect.Interface &amp;&amp; value.Type().NumMethod() == 0 {</td></tr>
<tr id="L474" class="miss"><td>474</td><td>0</td><td>			value = reflect.ValueOf(value.Interface()) // lovely!</td></tr>
<tr id="L475" class="miss"><td>475</td><td>0</td><td>		}</td></tr>
<tr id="L476"><td>476</td><td></td><td>	}</td></tr>
<tr id="L477" class="hit"><td>477</td><td>9</td><td>	for _, variable := range pipe.Decl {</td></tr>
<tr id="L478" class="miss"><td>478</td><td>0</td><td>		if pipe.IsAssign {</td></tr>
<tr id="L479" class="miss"><td>479</td><td>0</td><td>			s.setVar(variable.Ident[0], value)</td></tr>
<tr id="L480" class="miss"><td>480</td><td>0</td><td>		} else {</td></tr>
<tr id="L481" class="miss"><td>481</td><td>0</td><td>			s.push(variable.Ident[0], value)</td></tr>
<tr id="L482" class="miss"><td>482</td><td>0</td><td>		}</td></tr>
<tr id="L483"><td>483</td><td></td><td>	}</td></tr>
<tr id="L484" class="hit"><td>484</td><td>9</td><td>	return value</td></tr>
<tr id="L485"><td>485</td><td></td><td>}</td></tr>
<tr id="L486"><td>486</td><td></td><td></td></tr>
<tr id="L487" class="miss"><td>487</td><td>0</td><td>func (s *state) notAFunction(args []parse.Node, final reflect.Value) {</td></tr>
<tr id="L488" class="miss"><td>488</td><td>0</td><td>	if len(args) &gt; 1 || !isMissing(final) {</td></tr>
<tr id="L489" class="miss"><td>489</td><td>0</td><td>		s.errorf(&#34;can&#39;t give argument to non-function %s&#34;, args[0])</td></tr>
<tr id="L490" class="miss"><td>490</td><td>0</td><td>	}</td></tr>
<tr id="L491"><td>491</td><td></td><td>}</td></tr>
<tr id="L492"><td>492</td><td></td><td></td></tr>
<tr id="L493" class="hit"><td>493</td><td>9</td><td>func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value {</td></tr>
<tr id="L494" class="hit"><td>494</td><td>9</td><td>	firstWord := cmd.Args[0]</td></tr>
<tr id="L495" class="hit"><td>495</td><td>9</td><td>	switch n := firstWord.(type) {</td></tr>
<tr id="L496" class="hit"><td>496</td><td>9</td><td>	case *parse.FieldNode:</td></tr>
<tr id="L497" class="hit"><td>497</td><td>9</td><td>		return s.evalFieldNode(dot, n, cmd.Args, final)</td></tr>
<tr id="L498" class="miss"><td>498</td><td>0</td><td>	case *parse.ChainNode:</td></tr>
<tr id="L499" class="miss"><td>499</td><td>0</td><td>		return s.evalChainNode(dot, n, cmd.Args, final)</td></tr>
<tr id="L500" class="hit"><td>500</td><td>9</td><td>	case *parse.IdentifierNode:</td></tr>
<tr id="L501" class="hit"><td>501</td><td>9</td><td>		// Must be a function.</td></tr>
<tr id="L502" class="hit"><td>502</td><td>9</td><td>		return s.evalFunction(dot, n, cmd, cmd.Args, final)</td></tr>
<tr id="L503" class="miss"><td>503</td><td>0</td><td>	case *parse.PipeNode:</td></tr>
<tr id="L504" class="miss"><td>504</td><td>0</td><td>		// Parenthesized pipeline. The arguments are all inside the pipeline; final must be absent.</td></tr>
<tr id="L505" class="miss"><td>505</td><td>0</td><td>		s.notAFunction(cmd.Args, final)</td></tr>
<tr id="L506" class="miss"><td>506</td><td>0</td><td>		return s.evalPipeline(dot, n)</td></tr>
<tr id="L507" class="miss"><td>507</td><td>0</td><td>	case *parse.VariableNode:</td></tr>
<tr id="L508" class="miss"><td>508</td><td>0</td><td>		return s.evalVariableNode(dot, n, cmd.Args, final)</td></tr>
<tr id="L509"><td>509</td><td></td><td>	}</td></tr>
<tr id="L510" class="miss"><td>510</td><td>0</td><td>	s.at(firstWord)</td></tr>
<tr id="L511" class="miss"><td>511</td><td>0</td><td>	s.notAFunction(cmd.Args, final)</td></tr>
<tr id="L512" class="miss"><td>512</td><td>0</td><td>	switch word := firstWord.(type) {</td></tr>
<tr id="L513" class="miss"><td>513</td><td>0</td><td>	case *parse.BoolNode:</td></tr>
<tr id="L514" class="miss"><td>514</td><td>0</td><td>		return reflect.ValueOf(word.True)</td></tr>
<tr id="L515" class="miss"><td>515</td><td>0</td><td>	case *parse.DotNode:</td></tr>
<tr id="L516" class="miss"><td>516</td><td>0</td><td>		return dot</td></tr>
<tr id="L517" class="miss"><td>517</td><td>0</td><td>	case *parse.NilNode:</td></tr>
<tr id="L518" class="miss"><td>518</td><td>0</td><td>		s.errorf(&#34;nil is not a command&#34;)</td></tr>
<tr id="L519" class="miss"><td>519</td><td>0</td><td>	case *parse.NumberNode:</td></tr>
<tr id="L520" class="miss"><td>520</td><td>0</td><td>		return s.idealConstant(word)</td></tr>
<tr id="L521" class="miss"><td>521</td><td>0</td><td>	case *parse.StringNode:</td></tr>
<tr id="L522" class="miss"><td>522</td><td>0</td><td>		return reflect.ValueOf(word.Text)</td></tr>
<tr id="L523"><td>523</td><td></td><td>	}</td></tr>
<tr id="L524" class="miss"><td>524</td><td>0</td><td>	s.errorf(&#34;can&#39;t evaluate command %q&#34;, firstWord)</td></tr>
<tr id="L525" class="miss"><td>525</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L526"><td>526</td><td></td><td>}</td></tr>
<tr id="L527"><td>527</td><td></td><td></td></tr>
<tr id="L528"><td>528</td><td></td><td>// idealConstant is called to return the value of a number in a context where</td></tr>
<tr id="L529"><td>529</td><td></td><td>// we don&#39;t know the type. In that case, the syntax of the number tells us</td></tr>
<tr id="L530"><td>530</td><td></td><td>// its type, and we use Go rules to resolve. Note there is no such thing as</td></tr>
<tr id="L531"><td>531</td><td></td><td>// a uint ideal constant in this situation - the value must be of int type.</td></tr>
<tr id="L532" class="miss"><td>532</td><td>0</td><td>func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value {</td></tr>
<tr id="L533" class="miss"><td>533</td><td>0</td><td>	// These are ideal constants but we don&#39;t know the type</td></tr>
<tr id="L534" class="miss"><td>534</td><td>0</td><td>	// and we have no context.  (If it was a method argument,</td></tr>
<tr id="L535" class="miss"><td>535</td><td>0</td><td>	// we&#39;d know what we need.) The syntax guides us to some extent.</td></tr>
<tr id="L536" class="miss"><td>536</td><td>0</td><td>	s.at(constant)</td></tr>
<tr id="L537" class="miss"><td>537</td><td>0</td><td>	switch {</td></tr>
<tr id="L538" class="miss"><td>538</td><td>0</td><td>	case constant.IsComplex:</td></tr>
<tr id="L539" class="miss"><td>539</td><td>0</td><td>		return reflect.ValueOf(constant.Complex128) // incontrovertible.</td></tr>
<tr id="L540"><td>540</td><td></td><td></td></tr>
<tr id="L541"><td>541</td><td></td><td>	case constant.IsFloat &amp;&amp;</td></tr>
<tr id="L542"><td>542</td><td></td><td>		!isHexInt(constant.Text) &amp;&amp; !isRuneInt(constant.Text) &amp;&amp;</td></tr>
<tr id="L543" class="miss"><td>543</td><td>0</td><td>		strings.ContainsAny(constant.Text, &#34;.eEpP&#34;):</td></tr>
<tr id="L544" class="miss"><td>544</td><td>0</td><td>		return reflect.ValueOf(constant.Float64)</td></tr>
<tr id="L545"><td>545</td><td></td><td></td></tr>
<tr id="L546" class="miss"><td>546</td><td>0</td><td>	case constant.IsInt:</td></tr>
<tr id="L547" class="miss"><td>547</td><td>0</td><td>		n := int(constant.Int64)</td></tr>
<tr id="L548" class="miss"><td>548</td><td>0</td><td>		if int64(n) != constant.Int64 {</td></tr>
<tr id="L549" class="miss"><td>549</td><td>0</td><td>			s.errorf(&#34;%s overflows int&#34;, constant.Text)</td></tr>
<tr id="L550" class="miss"><td>550</td><td>0</td><td>		}</td></tr>
<tr id="L551" class="miss"><td>551</td><td>0</td><td>		return reflect.ValueOf(n)</td></tr>
<tr id="L552"><td>552</td><td></td><td></td></tr>
<tr id="L553" class="miss"><td>553</td><td>0</td><td>	case constant.IsUint:</td></tr>
<tr id="L554" class="miss"><td>554</td><td>0</td><td>		s.errorf(&#34;%s overflows int&#34;, constant.Text)</td></tr>
<tr id="L555"><td>555</td><td></td><td>	}</td></tr>
<tr id="L556" class="miss"><td>556</td><td>0</td><td>	return zero</td></tr>
<tr id="L557"><td>557</td><td></td><td>}</td></tr>
<tr id="L558"><td>558</td><td></td><td></td></tr>
<tr id="L559" class="miss"><td>559</td><td>0</td><td>func isRuneInt(s string) bool {</td></tr>
<tr id="L560" class="miss"><td>560</td><td>0</td><td>	return len(s) &gt; 0 &amp;&amp; s[0] == &#39;\&#39;&#39;</td></tr>
<tr id="L561" class="miss"><td>561</td><td>0</td><td>}</td></tr>
<tr id="L562"><td>562</td><td></td><td></td></tr>
<tr id="L563" class="miss"><td>563</td><td>0</td><td>func isHexInt(s string) bool {</td></tr>
<tr id="L564" class="miss"><td>564</td><td>0</td><td>	return len(s) &gt; 2 &amp;&amp; s[0] == &#39;0&#39; &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;) &amp;&amp; !strings.ContainsAny(s, &#34;pP&#34;)</td></tr>
<tr id="L565" class="miss"><td>565</td><td>0</td><td>}</td></tr>
<tr id="L566"><td>566</td><td></td><td></td></tr>
<tr id="L567" class="hit"><td>567</td><td>9</td><td>func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L568" class="hit"><td>568</td><td>9</td><td>	s.at(field)</td></tr>
<tr id="L569" class="hit"><td>569</td><td>9</td><td>	return s.evalFieldChain(dot, dot, field, field.Ident, args, final)</td></tr>
<tr id="L570" class="hit"><td>570</td><td>9</td><td>}</td></tr>
<tr id="L571"><td>571</td><td></td><td></td></tr>
<tr id="L572" class="miss"><td>572</td><td>0</td><td>func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L573" class="miss"><td>573</td><td>0</td><td>	s.at(chain)</td></tr>
<tr id="L574" class="miss"><td>574</td><td>0</td><td>	if len(chain.Field) == 0 {</td></tr>
<tr id="L575" class="miss"><td>575</td><td>0</td><td>		s.errorf(&#34;internal error: no fields in evalChainNode&#34;)</td></tr>
<tr id="L576" class="miss"><td>576</td><td>0</td><td>	}</td></tr>
<tr id="L577" class="miss"><td>577</td><td>0</td><td>	if chain.Node.Type() == parse.NodeNil {</td></tr>
<tr id="L578" class="miss"><td>578</td><td>0</td><td>		s.errorf(&#34;indirection through explicit nil in %s&#34;, chain)</td></tr>
<tr id="L579" class="miss"><td>579</td><td>0</td><td>	}</td></tr>
<tr id="L580"><td>580</td><td></td><td>	// (pipe).Field1.Field2 has pipe as .Node, fields as .Field. Eval the pipeline, then the fields.</td></tr>
<tr id="L581" class="miss"><td>581</td><td>0</td><td>	pipe := s.evalArg(dot, nil, chain.Node)</td></tr>
<tr id="L582" class="miss"><td>582</td><td>0</td><td>	return s.evalFieldChain(dot, pipe, chain, chain.Field, args, final)</td></tr>
<tr id="L583"><td>583</td><td></td><td>}</td></tr>
<tr id="L584"><td>584</td><td></td><td></td></tr>
<tr id="L585" class="miss"><td>585</td><td>0</td><td>func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L586" class="miss"><td>586</td><td>0</td><td>	// $x.Field has $x as the first ident, Field as the second. Eval the var, then the fields.</td></tr>
<tr id="L587" class="miss"><td>587</td><td>0</td><td>	s.at(variable)</td></tr>
<tr id="L588" class="miss"><td>588</td><td>0</td><td>	value := s.varValue(variable.Ident[0])</td></tr>
<tr id="L589" class="miss"><td>589</td><td>0</td><td>	if len(variable.Ident) == 1 {</td></tr>
<tr id="L590" class="miss"><td>590</td><td>0</td><td>		s.notAFunction(args, final)</td></tr>
<tr id="L591" class="miss"><td>591</td><td>0</td><td>		return value</td></tr>
<tr id="L592" class="miss"><td>592</td><td>0</td><td>	}</td></tr>
<tr id="L593" class="miss"><td>593</td><td>0</td><td>	return s.evalFieldChain(dot, value, variable, variable.Ident[1:], args, final)</td></tr>
<tr id="L594"><td>594</td><td></td><td>}</td></tr>
<tr id="L595"><td>595</td><td></td><td></td></tr>
<tr id="L596"><td>596</td><td></td><td>// evalFieldChain evaluates .X.Y.Z possibly followed by arguments.</td></tr>
<tr id="L597"><td>597</td><td></td><td>// dot is the environment in which to evaluate arguments, while</td></tr>
<tr id="L598"><td>598</td><td></td><td>// receiver is the value being walked along the chain.</td></tr>
<tr id="L599" class="hit"><td>599</td><td>9</td><td>func (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L600" class="hit"><td>600</td><td>9</td><td>	n := len(ident)</td></tr>
<tr id="L601" class="hit"><td>601</td><td>9</td><td>	for i := 0; i &lt; n-1; i++ {</td></tr>
<tr id="L602" class="miss"><td>602</td><td>0</td><td>		receiver = s.evalField(dot, ident[i], node, nil, missingVal, receiver)</td></tr>
<tr id="L603" class="miss"><td>603</td><td>0</td><td>	}</td></tr>
<tr id="L604"><td>604</td><td></td><td>	// Now if it&#39;s a method, it gets the arguments.</td></tr>
<tr id="L605" class="hit"><td>605</td><td>9</td><td>	return s.evalField(dot, ident[n-1], node, args, final, receiver)</td></tr>
<tr id="L606"><td>606</td><td></td><td>}</td></tr>
<tr id="L607"><td>607</td><td></td><td></td></tr>
<tr id="L608" class="hit"><td>608</td><td>9</td><td>func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L609" class="hit"><td>609</td><td>9</td><td>	s.at(node)</td></tr>
<tr id="L610" class="hit"><td>610</td><td>9</td><td>	name := node.Ident</td></tr>
<tr id="L611" class="hit"><td>611</td><td>9</td><td>	function, isBuiltin, ok := findFunction(name, s.tmpl)</td></tr>
<tr id="L612" class="hit"><td>612</td><td>9</td><td>	if !ok {</td></tr>
<tr id="L613" class="miss"><td>613</td><td>0</td><td>		s.errorf(&#34;%q is not a defined function&#34;, name)</td></tr>
<tr id="L614" class="miss"><td>614</td><td>0</td><td>	}</td></tr>
<tr id="L615" class="hit"><td>615</td><td>9</td><td>	return s.evalCall(dot, function, isBuiltin, cmd, name, args, final)</td></tr>
<tr id="L616"><td>616</td><td></td><td>}</td></tr>
<tr id="L617"><td>617</td><td></td><td></td></tr>
<tr id="L618"><td>618</td><td></td><td>// evalField evaluates an expression like (.Field) or (.Field arg1 arg2).</td></tr>
<tr id="L619"><td>619</td><td></td><td>// The &#39;final&#39; argument represents the return value from the preceding</td></tr>
<tr id="L620"><td>620</td><td></td><td>// value of the pipeline, if any.</td></tr>
<tr id="L621" class="hit"><td>621</td><td>9</td><td>func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value {</td></tr>
<tr id="L622" class="hit"><td>622</td><td>9</td><td>	if !receiver.IsValid() {</td></tr>
<tr id="L623" class="miss"><td>623</td><td>0</td><td>		if s.tmpl.option.missingKey == mapError { // Treat invalid value as missing map key.</td></tr>
<tr id="L624" class="miss"><td>624</td><td>0</td><td>			s.errorf(&#34;nil data; no entry for key %q&#34;, fieldName)</td></tr>
<tr id="L625" class="miss"><td>625</td><td>0</td><td>		}</td></tr>
<tr id="L626" class="miss"><td>626</td><td>0</td><td>		return zero</td></tr>
<tr id="L627"><td>627</td><td></td><td>	}</td></tr>
<tr id="L628" class="hit"><td>628</td><td>9</td><td>	typ := receiver.Type()</td></tr>
<tr id="L629" class="hit"><td>629</td><td>9</td><td>	receiver, isNil := indirect(receiver)</td></tr>
<tr id="L630" class="hit"><td>630</td><td>9</td><td>	if receiver.Kind() == reflect.Interface &amp;&amp; isNil {</td></tr>
<tr id="L631" class="miss"><td>631</td><td>0</td><td>		// Calling a method on a nil interface can&#39;t work. The</td></tr>
<tr id="L632" class="miss"><td>632</td><td>0</td><td>		// MethodByName method call below would panic.</td></tr>
<tr id="L633" class="miss"><td>633</td><td>0</td><td>		s.errorf(&#34;nil pointer evaluating %s.%s&#34;, typ, fieldName)</td></tr>
<tr id="L634" class="miss"><td>634</td><td>0</td><td>		return zero</td></tr>
<tr id="L635" class="miss"><td>635</td><td>0</td><td>	}</td></tr>
<tr id="L636"><td>636</td><td></td><td></td></tr>
<tr id="L637"><td>637</td><td></td><td>	// Unless it&#39;s an interface, need to get to a value of type *T to guarantee</td></tr>
<tr id="L638"><td>638</td><td></td><td>	// we see all methods of T and *T.</td></tr>
<tr id="L639" class="hit"><td>639</td><td>9</td><td>	ptr := receiver</td></tr>
<tr id="L640" class="hit"><td>640</td><td>9</td><td>	if ptr.Kind() != reflect.Interface &amp;&amp; ptr.Kind() != reflect.Pointer &amp;&amp; ptr.CanAddr() {</td></tr>
<tr id="L641" class="miss"><td>641</td><td>0</td><td>		ptr = ptr.Addr()</td></tr>
<tr id="L642" class="miss"><td>642</td><td>0</td><td>	}</td></tr>
<tr id="L643" class="hit"><td>643</td><td>9</td><td>	if method := ptr.MethodByName(fieldName); method.IsValid() {</td></tr>
<tr id="L644" class="miss"><td>644</td><td>0</td><td>		return s.evalCall(dot, method, false, node, fieldName, args, final)</td></tr>
<tr id="L645" class="miss"><td>645</td><td>0</td><td>	}</td></tr>
<tr id="L646" class="hit"><td>646</td><td>9</td><td>	hasArgs := len(args) &gt; 1 || !isMissing(final)</td></tr>
<tr id="L647" class="hit"><td>647</td><td>9</td><td>	// It&#39;s not a method; must be a field of a struct or an element of a map.</td></tr>
<tr id="L648" class="hit"><td>648</td><td>9</td><td>	switch receiver.Kind() {</td></tr>
<tr id="L649" class="hit"><td>649</td><td>9</td><td>	case reflect.Struct:</td></tr>
<tr id="L650" class="hit"><td>650</td><td>9</td><td>		tField, ok := receiver.Type().FieldByName(fieldName)</td></tr>
<tr id="L651" class="hit"><td>651</td><td>18</td><td>		if ok {</td></tr>
<tr id="L652" class="hit"><td>652</td><td>9</td><td>			field, err := receiver.FieldByIndexErr(tField.Index)</td></tr>
<tr id="L653" class="hit"><td>653</td><td>9</td><td>			if !tField.IsExported() {</td></tr>
<tr id="L654" class="miss"><td>654</td><td>0</td><td>				s.errorf(&#34;%s is an unexported field of struct type %s&#34;, fieldName, typ)</td></tr>
<tr id="L655" class="miss"><td>655</td><td>0</td><td>			}</td></tr>
<tr id="L656" class="hit"><td>656</td><td>9</td><td>			if err != nil {</td></tr>
<tr id="L657" class="miss"><td>657</td><td>0</td><td>				s.errorf(&#34;%v&#34;, err)</td></tr>
<tr id="L658" class="miss"><td>658</td><td>0</td><td>			}</td></tr>
<tr id="L659"><td>659</td><td></td><td>			// If it&#39;s a function, we must call it.</td></tr>
<tr id="L660" class="hit"><td>660</td><td>9</td><td>			if hasArgs {</td></tr>
<tr id="L661" class="miss"><td>661</td><td>0</td><td>				s.errorf(&#34;%s has arguments but cannot be invoked as function&#34;, fieldName)</td></tr>
<tr id="L662" class="miss"><td>662</td><td>0</td><td>			}</td></tr>
<tr id="L663" class="hit"><td>663</td><td>9</td><td>			return field</td></tr>
<tr id="L664"><td>664</td><td></td><td>		}</td></tr>
<tr id="L665" class="miss"><td>665</td><td>0</td><td>	case reflect.Map:</td></tr>
<tr id="L666" class="miss"><td>666</td><td>0</td><td>		// If it&#39;s a map, attempt to use the field name as a key.</td></tr>
<tr id="L667" class="miss"><td>667</td><td>0</td><td>		nameVal := reflect.ValueOf(fieldName)</td></tr>
<tr id="L668" class="miss"><td>668</td><td>0</td><td>		if nameVal.Type().AssignableTo(receiver.Type().Key()) {</td></tr>
<tr id="L669" class="miss"><td>669</td><td>0</td><td>			if hasArgs {</td></tr>
<tr id="L670" class="miss"><td>670</td><td>0</td><td>				s.errorf(&#34;%s is not a method but has arguments&#34;, fieldName)</td></tr>
<tr id="L671" class="miss"><td>671</td><td>0</td><td>			}</td></tr>
<tr id="L672" class="miss"><td>672</td><td>0</td><td>			result := receiver.MapIndex(nameVal)</td></tr>
<tr id="L673" class="miss"><td>673</td><td>0</td><td>			if !result.IsValid() {</td></tr>
<tr id="L674" class="miss"><td>674</td><td>0</td><td>				switch s.tmpl.option.missingKey {</td></tr>
<tr id="L675" class="miss"><td>675</td><td>0</td><td>				case mapInvalid:</td></tr>
<tr id="L676"><td>676</td><td></td><td>					// Just use the invalid value.</td></tr>
<tr id="L677" class="miss"><td>677</td><td>0</td><td>				case mapZeroValue:</td></tr>
<tr id="L678" class="miss"><td>678</td><td>0</td><td>					result = reflect.Zero(receiver.Type().Elem())</td></tr>
<tr id="L679" class="miss"><td>679</td><td>0</td><td>				case mapError:</td></tr>
<tr id="L680" class="miss"><td>680</td><td>0</td><td>					s.errorf(&#34;map has no entry for key %q&#34;, fieldName)</td></tr>
<tr id="L681"><td>681</td><td></td><td>				}</td></tr>
<tr id="L682"><td>682</td><td></td><td>			}</td></tr>
<tr id="L683" class="miss"><td>683</td><td>0</td><td>			return result</td></tr>
<tr id="L684"><td>684</td><td></td><td>		}</td></tr>
<tr id="L685" class="miss"><td>685</td><td>0</td><td>	case reflect.Pointer:</td></tr>
<tr id="L686" class="miss"><td>686</td><td>0</td><td>		etyp := receiver.Type().Elem()</td></tr>
<tr id="L687" class="miss"><td>687</td><td>0</td><td>		if etyp.Kind() == reflect.Struct {</td></tr>
<tr id="L688" class="miss"><td>688</td><td>0</td><td>			if _, ok := etyp.FieldByName(fieldName); !ok {</td></tr>
<tr id="L689" class="miss"><td>689</td><td>0</td><td>				// If there&#39;s no such field, say &#34;can&#39;t evaluate&#34;</td></tr>
<tr id="L690" class="miss"><td>690</td><td>0</td><td>				// instead of &#34;nil pointer evaluating&#34;.</td></tr>
<tr id="L691" class="miss"><td>691</td><td>0</td><td>				break</td></tr>
<tr id="L692"><td>692</td><td></td><td>			}</td></tr>
<tr id="L693"><td>693</td><td></td><td>		}</td></tr>
<tr id="L694" class="miss"><td>694</td><td>0</td><td>		if isNil {</td></tr>
<tr id="L695" class="miss"><td>695</td><td>0</td><td>			s.errorf(&#34;nil pointer evaluating %s.%s&#34;, typ, fieldName)</td></tr>
<tr id="L696" class="miss"><td>696</td><td>0</td><td>		}</td></tr>
<tr id="L697"><td>697</td><td></td><td>	}</td></tr>
<tr id="L698" class="miss"><td>698</td><td>0</td><td>	s.errorf(&#34;can&#39;t evaluate field %s in type %s&#34;, fieldName, typ)</td></tr>
<tr id="L699" class="miss"><td>699</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L700"><td>700</td><td></td><td>}</td></tr>
<tr id="L701"><td>701</td><td></td><td></td></tr>
<tr id="L702"><td>702</td><td></td><td>var (</td></tr>
<tr id="L703"><td>703</td><td></td><td>	errorType        = reflect.TypeOf((*error)(nil)).Elem()</td></tr>
<tr id="L704"><td>704</td><td></td><td>	fmtStringerType  = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()</td></tr>
<tr id="L705"><td>705</td><td></td><td>	reflectValueType = reflect.TypeOf((*reflect.Value)(nil)).Elem()</td></tr>
<tr id="L706"><td>706</td><td></td><td>)</td></tr>
<tr id="L707"><td>707</td><td></td><td></td></tr>
<tr id="L708"><td>708</td><td></td><td>// evalCall executes a function or method call. If it&#39;s a method, fun already has the receiver bound, so</td></tr>
<tr id="L709"><td>709</td><td></td><td>// it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0]</td></tr>
<tr id="L710"><td>710</td><td></td><td>// as the function itself.</td></tr>
<tr id="L711" class="hit"><td>711</td><td>9</td><td>func (s *state) evalCall(dot, fun reflect.Value, isBuiltin bool, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value {</td></tr>
<tr id="L712" class="hit"><td>712</td><td>18</td><td>	if args != nil {</td></tr>
<tr id="L713" class="hit"><td>713</td><td>9</td><td>		args = args[1:] // Zeroth arg is function name/node; not passed to function.</td></tr>
<tr id="L714" class="hit"><td>714</td><td>9</td><td>	}</td></tr>
<tr id="L715" class="hit"><td>715</td><td>9</td><td>	typ := fun.Type()</td></tr>
<tr id="L716" class="hit"><td>716</td><td>9</td><td>	numIn := len(args)</td></tr>
<tr id="L717" class="hit"><td>717</td><td>18</td><td>	if !isMissing(final) {</td></tr>
<tr id="L718" class="hit"><td>718</td><td>9</td><td>		numIn++</td></tr>
<tr id="L719" class="hit"><td>719</td><td>9</td><td>	}</td></tr>
<tr id="L720" class="hit"><td>720</td><td>9</td><td>	numFixed := len(args)</td></tr>
<tr id="L721" class="hit"><td>721</td><td>18</td><td>	if typ.IsVariadic() {</td></tr>
<tr id="L722" class="hit"><td>722</td><td>9</td><td>		numFixed = typ.NumIn() - 1 // last arg is the variadic one.</td></tr>
<tr id="L723" class="hit"><td>723</td><td>9</td><td>		if numIn &lt; numFixed {</td></tr>
<tr id="L724" class="miss"><td>724</td><td>0</td><td>			s.errorf(&#34;wrong number of args for %s: want at least %d got %d&#34;, name, typ.NumIn()-1, len(args))</td></tr>
<tr id="L725" class="miss"><td>725</td><td>0</td><td>		}</td></tr>
<tr id="L726" class="miss"><td>726</td><td>0</td><td>	} else if numIn != typ.NumIn() {</td></tr>
<tr id="L727" class="miss"><td>727</td><td>0</td><td>		s.errorf(&#34;wrong number of args for %s: want %d got %d&#34;, name, typ.NumIn(), numIn)</td></tr>
<tr id="L728" class="miss"><td>728</td><td>0</td><td>	}</td></tr>
<tr id="L729" class="hit"><td>729</td><td>9</td><td>	if !goodFunc(typ) {</td></tr>
<tr id="L730" class="miss"><td>730</td><td>0</td><td>		// TODO: This could still be a confusing error; maybe goodFunc should provide info.</td></tr>
<tr id="L731" class="miss"><td>731</td><td>0</td><td>		s.errorf(&#34;can&#39;t call method/function %q with %d results&#34;, name, typ.NumOut())</td></tr>
<tr id="L732" class="miss"><td>732</td><td>0</td><td>	}</td></tr>
<tr id="L733"><td>733</td><td></td><td></td></tr>
<tr id="L734" class="hit"><td>734</td><td>18</td><td>	unwrap := func(v reflect.Value) reflect.Value {</td></tr>
<tr id="L735" class="hit"><td>735</td><td>9</td><td>		if v.Type() == reflectValueType {</td></tr>
<tr id="L736" class="miss"><td>736</td><td>0</td><td>			v = v.Interface().(reflect.Value)</td></tr>
<tr id="L737" class="miss"><td>737</td><td>0</td><td>		}</td></tr>
<tr id="L738" class="hit"><td>738</td><td>9</td><td>		return v</td></tr>
<tr id="L739"><td>739</td><td></td><td>	}</td></tr>
<tr id="L740"><td>740</td><td></td><td></td></tr>
<tr id="L741"><td>741</td><td></td><td>	// Special case for builtin and/or, which short-circuit.</td></tr>
<tr id="L742" class="hit"><td>742</td><td>9</td><td>	if isBuiltin &amp;&amp; (name == &#34;and&#34; || name == &#34;or&#34;) {</td></tr>
<tr id="L743" class="miss"><td>743</td><td>0</td><td>		argType := typ.In(0)</td></tr>
<tr id="L744" class="miss"><td>744</td><td>0</td><td>		var v reflect.Value</td></tr>
<tr id="L745" class="miss"><td>745</td><td>0</td><td>		for _, arg := range args {</td></tr>
<tr id="L746" class="miss"><td>746</td><td>0</td><td>			v = s.evalArg(dot, argType, arg).Interface().(reflect.Value)</td></tr>
<tr id="L747" class="miss"><td>747</td><td>0</td><td>			if truth(v) == (name == &#34;or&#34;) {</td></tr>
<tr id="L748" class="miss"><td>748</td><td>0</td><td>				// This value was already unwrapped</td></tr>
<tr id="L749" class="miss"><td>749</td><td>0</td><td>				// by the .Interface().(reflect.Value).</td></tr>
<tr id="L750" class="miss"><td>750</td><td>0</td><td>				return v</td></tr>
<tr id="L751" class="miss"><td>751</td><td>0</td><td>			}</td></tr>
<tr id="L752"><td>752</td><td></td><td>		}</td></tr>
<tr id="L753" class="miss"><td>753</td><td>0</td><td>		if final != missingVal {</td></tr>
<tr id="L754" class="miss"><td>754</td><td>0</td><td>			// The last argument to and/or is coming from</td></tr>
<tr id="L755" class="miss"><td>755</td><td>0</td><td>			// the pipeline. We didn&#39;t short circuit on an earlier</td></tr>
<tr id="L756" class="miss"><td>756</td><td>0</td><td>			// argument, so we are going to return this one.</td></tr>
<tr id="L757" class="miss"><td>757</td><td>0</td><td>			// We don&#39;t have to evaluate final, but we do</td></tr>
<tr id="L758" class="miss"><td>758</td><td>0</td><td>			// have to check its type. Then, since we are</td></tr>
<tr id="L759" class="miss"><td>759</td><td>0</td><td>			// going to return it, we have to unwrap it.</td></tr>
<tr id="L760" class="miss"><td>760</td><td>0</td><td>			v = unwrap(s.validateType(final, argType))</td></tr>
<tr id="L761" class="miss"><td>761</td><td>0</td><td>		}</td></tr>
<tr id="L762" class="miss"><td>762</td><td>0</td><td>		return v</td></tr>
<tr id="L763"><td>763</td><td></td><td>	}</td></tr>
<tr id="L764"><td>764</td><td></td><td></td></tr>
<tr id="L765"><td>765</td><td></td><td>	// Build the arg list.</td></tr>
<tr id="L766" class="hit"><td>766</td><td>9</td><td>	argv := make([]reflect.Value, numIn)</td></tr>
<tr id="L767" class="hit"><td>767</td><td>9</td><td>	// Args must be evaluated. Fixed args first.</td></tr>
<tr id="L768" class="hit"><td>768</td><td>9</td><td>	i := 0</td></tr>
<tr id="L769" class="hit"><td>769</td><td>9</td><td>	for ; i &lt; numFixed &amp;&amp; i &lt; len(args); i++ {</td></tr>
<tr id="L770" class="miss"><td>770</td><td>0</td><td>		argv[i] = s.evalArg(dot, typ.In(i), args[i])</td></tr>
<tr id="L771" class="miss"><td>771</td><td>0</td><td>	}</td></tr>
<tr id="L772"><td>772</td><td></td><td>	// Now the ... args.</td></tr>
<tr id="L773" class="hit"><td>773</td><td>18</td><td>	if typ.IsVariadic() {</td></tr>
<tr id="L774" class="hit"><td>774</td><td>9</td><td>		argType := typ.In(typ.NumIn() - 1).Elem() // Argument is a slice.</td></tr>
<tr id="L775" class="hit"><td>775</td><td>9</td><td>		for ; i &lt; len(args); i++ {</td></tr>
<tr id="L776" class="miss"><td>776</td><td>0</td><td>			argv[i] = s.evalArg(dot, argType, args[i])</td></tr>
<tr id="L777" class="miss"><td>777</td><td>0</td><td>		}</td></tr>
<tr id="L778"><td>778</td><td></td><td>	}</td></tr>
<tr id="L779"><td>779</td><td></td><td>	// Add final value if necessary.</td></tr>
<tr id="L780" class="hit"><td>780</td><td>18</td><td>	if !isMissing(final) {</td></tr>
<tr id="L781" class="hit"><td>781</td><td>9</td><td>		t := typ.In(typ.NumIn() - 1)</td></tr>
<tr id="L782" class="hit"><td>782</td><td>18</td><td>		if typ.IsVariadic() {</td></tr>
<tr id="L783" class="hit"><td>783</td><td>9</td><td>			if numIn-1 &lt; numFixed {</td></tr>
<tr id="L784" class="miss"><td>784</td><td>0</td><td>				// The added final argument corresponds to a fixed parameter of the function.</td></tr>
<tr id="L785" class="miss"><td>785</td><td>0</td><td>				// Validate against the type of the actual parameter.</td></tr>
<tr id="L786" class="miss"><td>786</td><td>0</td><td>				t = typ.In(numIn - 1)</td></tr>
<tr id="L787" class="hit"><td>787</td><td>9</td><td>			} else {</td></tr>
<tr id="L788" class="hit"><td>788</td><td>9</td><td>				// The added final argument corresponds to the variadic part.</td></tr>
<tr id="L789" class="hit"><td>789</td><td>9</td><td>				// Validate against the type of the elements of the variadic slice.</td></tr>
<tr id="L790" class="hit"><td>790</td><td>9</td><td>				t = t.Elem()</td></tr>
<tr id="L791" class="hit"><td>791</td><td>9</td><td>			}</td></tr>
<tr id="L792"><td>792</td><td></td><td>		}</td></tr>
<tr id="L793" class="hit"><td>793</td><td>9</td><td>		argv[i] = s.validateType(final, t)</td></tr>
<tr id="L794"><td>794</td><td></td><td>	}</td></tr>
<tr id="L795" class="hit"><td>795</td><td>9</td><td>	v, err := safeCall(fun, argv)</td></tr>
<tr id="L796" class="hit"><td>796</td><td>9</td><td>	// If we have an error that is not nil, stop execution and return that</td></tr>
<tr id="L797" class="hit"><td>797</td><td>9</td><td>	// error to the caller.</td></tr>
<tr id="L798" class="hit"><td>798</td><td>9</td><td>	if err != nil {</td></tr>
<tr id="L799" class="miss"><td>799</td><td>0</td><td>		s.at(node)</td></tr>
<tr id="L800" class="miss"><td>800</td><td>0</td><td>		s.errorf(&#34;error calling %s: %w&#34;, name, err)</td></tr>
<tr id="L801" class="miss"><td>801</td><td>0</td><td>	}</td></tr>
<tr id="L802" class="hit"><td>802</td><td>9</td><td>	return unwrap(v)</td></tr>
<tr id="L803"><td>803</td><td></td><td>}</td></tr>
<tr id="L804"><td>804</td><td></td><td></td></tr>
<tr id="L805"><td>805</td><td></td><td>// canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.</td></tr>
<tr id="L806" class="miss"><td>806</td><td>0</td><td>func canBeNil(typ reflect.Type) bool {</td></tr>
<tr id="L807" class="miss"><td>807</td><td>0</td><td>	switch typ.Kind() {</td></tr>
<tr id="L808" class="miss"><td>808</td><td>0</td><td>	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:</td></tr>
<tr id="L809" class="miss"><td>809</td><td>0</td><td>		return true</td></tr>
<tr id="L810" class="miss"><td>810</td><td>0</td><td>	case reflect.Struct:</td></tr>
<tr id="L811" class="miss"><td>811</td><td>0</td><td>		return typ == reflectValueType</td></tr>
<tr id="L812"><td>812</td><td></td><td>	}</td></tr>
<tr id="L813" class="miss"><td>813</td><td>0</td><td>	return false</td></tr>
<tr id="L814"><td>814</td><td></td><td>}</td></tr>
<tr id="L815"><td>815</td><td></td><td></td></tr>
<tr id="L816"><td>816</td><td></td><td>// validateType guarantees that the value is valid and assignable to the type.</td></tr>
<tr id="L817" class="hit"><td>817</td><td>9</td><td>func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value {</td></tr>
<tr id="L818" class="hit"><td>818</td><td>9</td><td>	if !value.IsValid() {</td></tr>
<tr id="L819" class="miss"><td>819</td><td>0</td><td>		if typ == nil {</td></tr>
<tr id="L820" class="miss"><td>820</td><td>0</td><td>			// An untyped nil interface{}. Accept as a proper nil value.</td></tr>
<tr id="L821" class="miss"><td>821</td><td>0</td><td>			return reflect.ValueOf(nil)</td></tr>
<tr id="L822" class="miss"><td>822</td><td>0</td><td>		}</td></tr>
<tr id="L823" class="miss"><td>823</td><td>0</td><td>		if canBeNil(typ) {</td></tr>
<tr id="L824" class="miss"><td>824</td><td>0</td><td>			// Like above, but use the zero value of the non-nil type.</td></tr>
<tr id="L825" class="miss"><td>825</td><td>0</td><td>			return reflect.Zero(typ)</td></tr>
<tr id="L826" class="miss"><td>826</td><td>0</td><td>		}</td></tr>
<tr id="L827" class="miss"><td>827</td><td>0</td><td>		s.errorf(&#34;invalid value; expected %s&#34;, typ)</td></tr>
<tr id="L828"><td>828</td><td></td><td>	}</td></tr>
<tr id="L829" class="hit"><td>829</td><td>9</td><td>	if typ == reflectValueType &amp;&amp; value.Type() != typ {</td></tr>
<tr id="L830" class="miss"><td>830</td><td>0</td><td>		return reflect.ValueOf(value)</td></tr>
<tr id="L831" class="miss"><td>831</td><td>0</td><td>	}</td></tr>
<tr id="L832" class="hit"><td>832</td><td>9</td><td>	if typ != nil &amp;&amp; !value.Type().AssignableTo(typ) {</td></tr>
<tr id="L833" class="miss"><td>833</td><td>0</td><td>		if value.Kind() == reflect.Interface &amp;&amp; !value.IsNil() {</td></tr>
<tr id="L834" class="miss"><td>834</td><td>0</td><td>			value = value.Elem()</td></tr>
<tr id="L835" class="miss"><td>835</td><td>0</td><td>			if value.Type().AssignableTo(typ) {</td></tr>
<tr id="L836" class="miss"><td>836</td><td>0</td><td>				return value</td></tr>
<tr id="L837" class="miss"><td>837</td><td>0</td><td>			}</td></tr>
<tr id="L838"><td>838</td><td></td><td>			// fallthrough</td></tr>
<tr id="L839"><td>839</td><td></td><td>		}</td></tr>
<tr id="L840"><td>840</td><td></td><td>		// Does one dereference or indirection work? We could do more, as we</td></tr>
<tr id="L841"><td>841</td><td></td><td>		// do with method receivers, but that gets messy and method receivers</td></tr>
<tr id="L842"><td>842</td><td></td><td>		// are much more constrained, so it makes more sense there than here.</td></tr>
<tr id="L843"><td>843</td><td></td><td>		// Besides, one is almost always all you need.</td></tr>
<tr id="L844" class="miss"><td>844</td><td>0</td><td>		switch {</td></tr>
<tr id="L845" class="miss"><td>845</td><td>0</td><td>		case value.Kind() == reflect.Pointer &amp;&amp; value.Type().Elem().AssignableTo(typ):</td></tr>
<tr id="L846" class="miss"><td>846</td><td>0</td><td>			value = value.Elem()</td></tr>
<tr id="L847" class="miss"><td>847</td><td>0</td><td>			if !value.IsValid() {</td></tr>
<tr id="L848" class="miss"><td>848</td><td>0</td><td>				s.errorf(&#34;dereference of nil pointer of type %s&#34;, typ)</td></tr>
<tr id="L849" class="miss"><td>849</td><td>0</td><td>			}</td></tr>
<tr id="L850" class="miss"><td>850</td><td>0</td><td>		case reflect.PointerTo(value.Type()).AssignableTo(typ) &amp;&amp; value.CanAddr():</td></tr>
<tr id="L851" class="miss"><td>851</td><td>0</td><td>			value = value.Addr()</td></tr>
<tr id="L852" class="miss"><td>852</td><td>0</td><td>		default:</td></tr>
<tr id="L853" class="miss"><td>853</td><td>0</td><td>			s.errorf(&#34;wrong type for value; expected %s; got %s&#34;, typ, value.Type())</td></tr>
<tr id="L854"><td>854</td><td></td><td>		}</td></tr>
<tr id="L855"><td>855</td><td></td><td>	}</td></tr>
<tr id="L856" class="hit"><td>856</td><td>9</td><td>	return value</td></tr>
<tr id="L857"><td>857</td><td></td><td>}</td></tr>
<tr id="L858"><td>858</td><td></td><td></td></tr>
<tr id="L859" class="miss"><td>859</td><td>0</td><td>func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L860" class="miss"><td>860</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L861" class="miss"><td>861</td><td>0</td><td>	switch arg := n.(type) {</td></tr>
<tr id="L862" class="miss"><td>862</td><td>0</td><td>	case *parse.DotNode:</td></tr>
<tr id="L863" class="miss"><td>863</td><td>0</td><td>		return s.validateType(dot, typ)</td></tr>
<tr id="L864" class="miss"><td>864</td><td>0</td><td>	case *parse.NilNode:</td></tr>
<tr id="L865" class="miss"><td>865</td><td>0</td><td>		if canBeNil(typ) {</td></tr>
<tr id="L866" class="miss"><td>866</td><td>0</td><td>			return reflect.Zero(typ)</td></tr>
<tr id="L867" class="miss"><td>867</td><td>0</td><td>		}</td></tr>
<tr id="L868" class="miss"><td>868</td><td>0</td><td>		s.errorf(&#34;cannot assign nil to %s&#34;, typ)</td></tr>
<tr id="L869" class="miss"><td>869</td><td>0</td><td>	case *parse.FieldNode:</td></tr>
<tr id="L870" class="miss"><td>870</td><td>0</td><td>		return s.validateType(s.evalFieldNode(dot, arg, []parse.Node{n}, missingVal), typ)</td></tr>
<tr id="L871" class="miss"><td>871</td><td>0</td><td>	case *parse.VariableNode:</td></tr>
<tr id="L872" class="miss"><td>872</td><td>0</td><td>		return s.validateType(s.evalVariableNode(dot, arg, nil, missingVal), typ)</td></tr>
<tr id="L873" class="miss"><td>873</td><td>0</td><td>	case *parse.PipeNode:</td></tr>
<tr id="L874" class="miss"><td>874</td><td>0</td><td>		return s.validateType(s.evalPipeline(dot, arg), typ)</td></tr>
<tr id="L875" class="miss"><td>875</td><td>0</td><td>	case *parse.IdentifierNode:</td></tr>
<tr id="L876" class="miss"><td>876</td><td>0</td><td>		return s.validateType(s.evalFunction(dot, arg, arg, nil, missingVal), typ)</td></tr>
<tr id="L877" class="miss"><td>877</td><td>0</td><td>	case *parse.ChainNode:</td></tr>
<tr id="L878" class="miss"><td>878</td><td>0</td><td>		return s.validateType(s.evalChainNode(dot, arg, nil, missingVal), typ)</td></tr>
<tr id="L879"><td>879</td><td></td><td>	}</td></tr>
<tr id="L880" class="miss"><td>880</td><td>0</td><td>	switch typ.Kind() {</td></tr>
<tr id="L881" class="miss"><td>881</td><td>0</td><td>	case reflect.Bool:</td></tr>
<tr id="L882" class="miss"><td>882</td><td>0</td><td>		return s.evalBool(typ, n)</td></tr>
<tr id="L883" class="miss"><td>883</td><td>0</td><td>	case reflect.Complex64, reflect.Complex128:</td></tr>
<tr id="L884" class="miss"><td>884</td><td>0</td><td>		return s.evalComplex(typ, n)</td></tr>
<tr id="L885" class="miss"><td>885</td><td>0</td><td>	case reflect.Float32, reflect.Float64:</td></tr>
<tr id="L886" class="miss"><td>886</td><td>0</td><td>		return s.evalFloat(typ, n)</td></tr>
<tr id="L887" class="miss"><td>887</td><td>0</td><td>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</td></tr>
<tr id="L888" class="miss"><td>888</td><td>0</td><td>		return s.evalInteger(typ, n)</td></tr>
<tr id="L889" class="miss"><td>889</td><td>0</td><td>	case reflect.Interface:</td></tr>
<tr id="L890" class="miss"><td>890</td><td>0</td><td>		if typ.NumMethod() == 0 {</td></tr>
<tr id="L891" class="miss"><td>891</td><td>0</td><td>			return s.evalEmptyInterface(dot, n)</td></tr>
<tr id="L892" class="miss"><td>892</td><td>0</td><td>		}</td></tr>
<tr id="L893" class="miss"><td>893</td><td>0</td><td>	case reflect.Struct:</td></tr>
<tr id="L894" class="miss"><td>894</td><td>0</td><td>		if typ == reflectValueType {</td></tr>
<tr id="L895" class="miss"><td>895</td><td>0</td><td>			return reflect.ValueOf(s.evalEmptyInterface(dot, n))</td></tr>
<tr id="L896" class="miss"><td>896</td><td>0</td><td>		}</td></tr>
<tr id="L897" class="miss"><td>897</td><td>0</td><td>	case reflect.String:</td></tr>
<tr id="L898" class="miss"><td>898</td><td>0</td><td>		return s.evalString(typ, n)</td></tr>
<tr id="L899" class="miss"><td>899</td><td>0</td><td>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</td></tr>
<tr id="L900" class="miss"><td>900</td><td>0</td><td>		return s.evalUnsignedInteger(typ, n)</td></tr>
<tr id="L901"><td>901</td><td></td><td>	}</td></tr>
<tr id="L902" class="miss"><td>902</td><td>0</td><td>	s.errorf(&#34;can&#39;t handle %s for arg of type %s&#34;, n, typ)</td></tr>
<tr id="L903" class="miss"><td>903</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L904"><td>904</td><td></td><td>}</td></tr>
<tr id="L905"><td>905</td><td></td><td></td></tr>
<tr id="L906" class="miss"><td>906</td><td>0</td><td>func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L907" class="miss"><td>907</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L908" class="miss"><td>908</td><td>0</td><td>	if n, ok := n.(*parse.BoolNode); ok {</td></tr>
<tr id="L909" class="miss"><td>909</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L910" class="miss"><td>910</td><td>0</td><td>		value.SetBool(n.True)</td></tr>
<tr id="L911" class="miss"><td>911</td><td>0</td><td>		return value</td></tr>
<tr id="L912" class="miss"><td>912</td><td>0</td><td>	}</td></tr>
<tr id="L913" class="miss"><td>913</td><td>0</td><td>	s.errorf(&#34;expected bool; found %s&#34;, n)</td></tr>
<tr id="L914" class="miss"><td>914</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L915"><td>915</td><td></td><td>}</td></tr>
<tr id="L916"><td>916</td><td></td><td></td></tr>
<tr id="L917" class="miss"><td>917</td><td>0</td><td>func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L918" class="miss"><td>918</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L919" class="miss"><td>919</td><td>0</td><td>	if n, ok := n.(*parse.StringNode); ok {</td></tr>
<tr id="L920" class="miss"><td>920</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L921" class="miss"><td>921</td><td>0</td><td>		value.SetString(n.Text)</td></tr>
<tr id="L922" class="miss"><td>922</td><td>0</td><td>		return value</td></tr>
<tr id="L923" class="miss"><td>923</td><td>0</td><td>	}</td></tr>
<tr id="L924" class="miss"><td>924</td><td>0</td><td>	s.errorf(&#34;expected string; found %s&#34;, n)</td></tr>
<tr id="L925" class="miss"><td>925</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L926"><td>926</td><td></td><td>}</td></tr>
<tr id="L927"><td>927</td><td></td><td></td></tr>
<tr id="L928" class="miss"><td>928</td><td>0</td><td>func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L929" class="miss"><td>929</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L930" class="miss"><td>930</td><td>0</td><td>	if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsInt {</td></tr>
<tr id="L931" class="miss"><td>931</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L932" class="miss"><td>932</td><td>0</td><td>		value.SetInt(n.Int64)</td></tr>
<tr id="L933" class="miss"><td>933</td><td>0</td><td>		return value</td></tr>
<tr id="L934" class="miss"><td>934</td><td>0</td><td>	}</td></tr>
<tr id="L935" class="miss"><td>935</td><td>0</td><td>	s.errorf(&#34;expected integer; found %s&#34;, n)</td></tr>
<tr id="L936" class="miss"><td>936</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L937"><td>937</td><td></td><td>}</td></tr>
<tr id="L938"><td>938</td><td></td><td></td></tr>
<tr id="L939" class="miss"><td>939</td><td>0</td><td>func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L940" class="miss"><td>940</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L941" class="miss"><td>941</td><td>0</td><td>	if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsUint {</td></tr>
<tr id="L942" class="miss"><td>942</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L943" class="miss"><td>943</td><td>0</td><td>		value.SetUint(n.Uint64)</td></tr>
<tr id="L944" class="miss"><td>944</td><td>0</td><td>		return value</td></tr>
<tr id="L945" class="miss"><td>945</td><td>0</td><td>	}</td></tr>
<tr id="L946" class="miss"><td>946</td><td>0</td><td>	s.errorf(&#34;expected unsigned integer; found %s&#34;, n)</td></tr>
<tr id="L947" class="miss"><td>947</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L948"><td>948</td><td></td><td>}</td></tr>
<tr id="L949"><td>949</td><td></td><td></td></tr>
<tr id="L950" class="miss"><td>950</td><td>0</td><td>func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L951" class="miss"><td>951</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L952" class="miss"><td>952</td><td>0</td><td>	if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsFloat {</td></tr>
<tr id="L953" class="miss"><td>953</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L954" class="miss"><td>954</td><td>0</td><td>		value.SetFloat(n.Float64)</td></tr>
<tr id="L955" class="miss"><td>955</td><td>0</td><td>		return value</td></tr>
<tr id="L956" class="miss"><td>956</td><td>0</td><td>	}</td></tr>
<tr id="L957" class="miss"><td>957</td><td>0</td><td>	s.errorf(&#34;expected float; found %s&#34;, n)</td></tr>
<tr id="L958" class="miss"><td>958</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L959"><td>959</td><td></td><td>}</td></tr>
<tr id="L960"><td>960</td><td></td><td></td></tr>
<tr id="L961" class="miss"><td>961</td><td>0</td><td>func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value {</td></tr>
<tr id="L962" class="miss"><td>962</td><td>0</td><td>	if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsComplex {</td></tr>
<tr id="L963" class="miss"><td>963</td><td>0</td><td>		value := reflect.New(typ).Elem()</td></tr>
<tr id="L964" class="miss"><td>964</td><td>0</td><td>		value.SetComplex(n.Complex128)</td></tr>
<tr id="L965" class="miss"><td>965</td><td>0</td><td>		return value</td></tr>
<tr id="L966" class="miss"><td>966</td><td>0</td><td>	}</td></tr>
<tr id="L967" class="miss"><td>967</td><td>0</td><td>	s.errorf(&#34;expected complex; found %s&#34;, n)</td></tr>
<tr id="L968" class="miss"><td>968</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L969"><td>969</td><td></td><td>}</td></tr>
<tr id="L970"><td>970</td><td></td><td></td></tr>
<tr id="L971" class="miss"><td>971</td><td>0</td><td>func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value {</td></tr>
<tr id="L972" class="miss"><td>972</td><td>0</td><td>	s.at(n)</td></tr>
<tr id="L973" class="miss"><td>973</td><td>0</td><td>	switch n := n.(type) {</td></tr>
<tr id="L974" class="miss"><td>974</td><td>0</td><td>	case *parse.BoolNode:</td></tr>
<tr id="L975" class="miss"><td>975</td><td>0</td><td>		return reflect.ValueOf(n.True)</td></tr>
<tr id="L976" class="miss"><td>976</td><td>0</td><td>	case *parse.DotNode:</td></tr>
<tr id="L977" class="miss"><td>977</td><td>0</td><td>		return dot</td></tr>
<tr id="L978" class="miss"><td>978</td><td>0</td><td>	case *parse.FieldNode:</td></tr>
<tr id="L979" class="miss"><td>979</td><td>0</td><td>		return s.evalFieldNode(dot, n, nil, missingVal)</td></tr>
<tr id="L980" class="miss"><td>980</td><td>0</td><td>	case *parse.IdentifierNode:</td></tr>
<tr id="L981" class="miss"><td>981</td><td>0</td><td>		return s.evalFunction(dot, n, n, nil, missingVal)</td></tr>
<tr id="L982" class="miss"><td>982</td><td>0</td><td>	case *parse.NilNode:</td></tr>
<tr id="L983" class="miss"><td>983</td><td>0</td><td>		// NilNode is handled in evalArg, the only place that calls here.</td></tr>
<tr id="L984" class="miss"><td>984</td><td>0</td><td>		s.errorf(&#34;evalEmptyInterface: nil (can&#39;t happen)&#34;)</td></tr>
<tr id="L985" class="miss"><td>985</td><td>0</td><td>	case *parse.NumberNode:</td></tr>
<tr id="L986" class="miss"><td>986</td><td>0</td><td>		return s.idealConstant(n)</td></tr>
<tr id="L987" class="miss"><td>987</td><td>0</td><td>	case *parse.StringNode:</td></tr>
<tr id="L988" class="miss"><td>988</td><td>0</td><td>		return reflect.ValueOf(n.Text)</td></tr>
<tr id="L989" class="miss"><td>989</td><td>0</td><td>	case *parse.VariableNode:</td></tr>
<tr id="L990" class="miss"><td>990</td><td>0</td><td>		return s.evalVariableNode(dot, n, nil, missingVal)</td></tr>
<tr id="L991" class="miss"><td>991</td><td>0</td><td>	case *parse.PipeNode:</td></tr>
<tr id="L992" class="miss"><td>992</td><td>0</td><td>		return s.evalPipeline(dot, n)</td></tr>
<tr id="L993"><td>993</td><td></td><td>	}</td></tr>
<tr id="L994" class="miss"><td>994</td><td>0</td><td>	s.errorf(&#34;can&#39;t handle assignment of %s to empty interface argument&#34;, n)</td></tr>
<tr id="L995" class="miss"><td>995</td><td>0</td><td>	panic(&#34;not reached&#34;)</td></tr>
<tr id="L996"><td>996</td><td></td><td>}</td></tr>
<tr id="L997"><td>997</td><td></td><td></td></tr>
<tr id="L998"><td>998</td><td></td><td>// indirect returns the item at the end of indirection, and a bool to indicate</td></tr>
<tr id="L999"><td>999</td><td></td><td>// if it&#39;s nil. If the returned bool is true, the returned value&#39;s kind will be</td></tr>
<tr id="L1000"><td>1000</td><td></td><td>// either a pointer or interface.</td></tr>
<tr id="L1001" class="hit"><td>1001</td><td>9</td><td>func indirect(v reflect.Value) (rv reflect.Value, isNil bool) {</td></tr>
<tr id="L1002" class="hit"><td>1002</td><td>9</td><td>	for ; v.Kind() == reflect.Pointer || v.Kind() == reflect.Interface; v = v.Elem() {</td></tr>
<tr id="L1003" class="miss"><td>1003</td><td>0</td><td>		if v.IsNil() {</td></tr>
<tr id="L1004" class="miss"><td>1004</td><td>0</td><td>			return v, true</td></tr>
<tr id="L1005" class="miss"><td>1005</td><td>0</td><td>		}</td></tr>
<tr id="L1006"><td>1006</td><td></td><td>	}</td></tr>
<tr id="L1007" class="hit"><td>1007</td><td>9</td><td>	return v, false</td></tr>
<tr id="L1008"><td>1008</td><td></td><td>}</td></tr>
<tr id="L1009"><td>1009</td><td></td><td></td></tr>
<tr id="L1010"><td>1010</td><td></td><td>// indirectInterface returns the concrete value in an interface value,</td></tr>
<tr id="L1011"><td>1011</td><td></td><td>// or else the zero reflect.Value.</td></tr>
<tr id="L1012"><td>1012</td><td></td><td>// That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x):</td></tr>
<tr id="L1013"><td>1013</td><td></td><td>// the fact that x was an interface value is forgotten.</td></tr>
<tr id="L1014" class="miss"><td>1014</td><td>0</td><td>func indirectInterface(v reflect.Value) reflect.Value {</td></tr>
<tr id="L1015" class="miss"><td>1015</td><td>0</td><td>	if v.Kind() != reflect.Interface {</td></tr>
<tr id="L1016" class="miss"><td>1016</td><td>0</td><td>		return v</td></tr>
<tr id="L1017" class="miss"><td>1017</td><td>0</td><td>	}</td></tr>
<tr id="L1018" class="miss"><td>1018</td><td>0</td><td>	if v.IsNil() {</td></tr>
<tr id="L1019" class="miss"><td>1019</td><td>0</td><td>		return reflect.Value{}</td></tr>
<tr id="L1020" class="miss"><td>1020</td><td>0</td><td>	}</td></tr>
<tr id="L1021" class="miss"><td>1021</td><td>0</td><td>	return v.Elem()</td></tr>
<tr id="L1022"><td>1022</td><td></td><td>}</td></tr>
<tr id="L1023"><td>1023</td><td></td><td></td></tr>
<tr id="L1024"><td>1024</td><td></td><td>// printValue writes the textual representation of the value to the output of</td></tr>
<tr id="L1025"><td>1025</td><td></td><td>// the template.</td></tr>
<tr id="L1026" class="hit"><td>1026</td><td>9</td><td>func (s *state) printValue(n parse.Node, v reflect.Value) {</td></tr>
<tr id="L1027" class="hit"><td>1027</td><td>9</td><td>	s.at(n)</td></tr>
<tr id="L1028" class="hit"><td>1028</td><td>9</td><td>	iface, ok := printableValue(v)</td></tr>
<tr id="L1029" class="hit"><td>1029</td><td>9</td><td>	if !ok {</td></tr>
<tr id="L1030" class="miss"><td>1030</td><td>0</td><td>		s.errorf(&#34;can&#39;t print %s of type %s&#34;, n, v.Type())</td></tr>
<tr id="L1031" class="miss"><td>1031</td><td>0</td><td>	}</td></tr>
<tr id="L1032" class="hit"><td>1032</td><td>9</td><td>	_, err := fmt.Fprint(s.wr, iface)</td></tr>
<tr id="L1033" class="hit"><td>1033</td><td>9</td><td>	if err != nil {</td></tr>
<tr id="L1034" class="miss"><td>1034</td><td>0</td><td>		s.writeError(err)</td></tr>
<tr id="L1035" class="miss"><td>1035</td><td>0</td><td>	}</td></tr>
<tr id="L1036"><td>1036</td><td></td><td>}</td></tr>
<tr id="L1037"><td>1037</td><td></td><td></td></tr>
<tr id="L1038"><td>1038</td><td></td><td>// printableValue returns the, possibly indirected, interface value inside v that</td></tr>
<tr id="L1039"><td>1039</td><td></td><td>// is best for a call to formatted printer.</td></tr>
<tr id="L1040" class="hit"><td>1040</td><td>9</td><td>func printableValue(v reflect.Value) (any, bool) {</td></tr>
<tr id="L1041" class="hit"><td>1041</td><td>9</td><td>	if v.Kind() == reflect.Pointer {</td></tr>
<tr id="L1042" class="miss"><td>1042</td><td>0</td><td>		v, _ = indirect(v) // fmt.Fprint handles nil.</td></tr>
<tr id="L1043" class="miss"><td>1043</td><td>0</td><td>	}</td></tr>
<tr id="L1044" class="hit"><td>1044</td><td>9</td><td>	if !v.IsValid() {</td></tr>
<tr id="L1045" class="miss"><td>1045</td><td>0</td><td>		return &#34;&lt;no value&gt;&#34;, true</td></tr>
<tr id="L1046" class="miss"><td>1046</td><td>0</td><td>	}</td></tr>
<tr id="L1047"><td>1047</td><td></td><td></td></tr>
<tr id="L1048" class="hit"><td>1048</td><td>18</td><td>	if !v.Type().Implements(errorType) &amp;&amp; !v.Type().Implements(fmtStringerType) {</td></tr>
<tr id="L1049" class="hit"><td>1049</td><td>9</td><td>		if v.CanAddr() &amp;&amp; (reflect.PointerTo(v.Type()).Implements(errorType) || reflect.PointerTo(v.Type()).Implements(fmtStringerType)) {</td></tr>
<tr id="L1050" class="miss"><td>1050</td><td>0</td><td>			v = v.Addr()</td></tr>
<tr id="L1051" class="hit"><td>1051</td><td>9</td><td>		} else {</td></tr>
<tr id="L1052" class="hit"><td>1052</td><td>9</td><td>			switch v.Kind() {</td></tr>
<tr id="L1053" class="miss"><td>1053</td><td>0</td><td>			case reflect.Chan, reflect.Func:</td></tr>
<tr id="L1054" class="miss"><td>1054</td><td>0</td><td>				return nil, false</td></tr>
<tr id="L1055"><td>1055</td><td></td><td>			}</td></tr>
<tr id="L1056"><td>1056</td><td></td><td>		}</td></tr>
<tr id="L1057"><td>1057</td><td></td><td>	}</td></tr>
<tr id="L1058" class="hit"><td>1058</td><td>9</td><td>	return v.Interface(), true</td></tr>
<tr id="L1059"><td>1059</td><td></td><td>}</td></tr>
</tbody></table>
</div></div>
<footer>Generated by <a href="https://gitlab.com/stone.code/scov">SCov</a>.</footer>
</body></html>